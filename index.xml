<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>xiantang</title>
    <link>https://xiantang.github.io/</link>
    <description>Recent content on xiantang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://xiantang.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/dp-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/dp-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/</guid>
      <description>我们主要通过三道子序列问题来分析 首先DP区间问题可以通过大问题划分成最优的子结构来解决。 也就是说每个最终解都是从子问题开始的。
  516.longest-palindromic-subsequence Given a string s, find the longest palindromic subsequence&amp;rsquo;s length in s. 我们采用一个二维的数组来记录历史，dp[i][j]表示的是索引i-j之间的最大字串。 我们可以发现下面三个情况:
 len=1 的时候表示dp[i][j]就只有一个字符，dp[i][j]=1 str[i]==str[j]就表示是回文，dp[i][j] = dp[i+1][j-1]+2 否则不是在前就是在后。  针对如何遍历所有序列我们采用这样的方式
for(int len=1;len&amp;lt;=s.length();len++){ // 起始位置  for(int i=0;i&amp;lt;=s.length()-len;i++){ // j的位置  int j = i+len-1; // do something  } }   </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/leetcode-todo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/leetcode-todo/</guid>
      <description>链表    链表的必备知识要点(包括基础知识、刷题中使用的STL等知识)     链表逆序(LeetCode 92,206. Reverse Linked List 1,2)     求两个链表的交点(LeetCode 160. Intersection of Two Linked Lists)     链表的节点交换(LeetCode 24. Swap Nodes in Pairs)     链表求环(LeetCode 141,142. Linked List Cycle 1,2)     链表重新构造(LeetCode 86. Partition List)     复杂的链表复制(LeetCode 138. Copy List with Random Pointer)     排序链表合并(2个与多个) (LeetCode 21,23 Merge Two(k) Sorted ListsLeetCode)    栈、队列、堆    栈、队列知识要点与实现(数组、链表)     使用队列实现栈(LeetCode 232.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/tree/</guid>
      <description>霍夫曼树 霍夫曼树又称最优二叉树，是一种带权路径长度最短的二叉树。
 根据给定的n个权值(W1,W2&amp;hellip;Wn)，使对应节点构成n个二叉树的森林T=(T1,T2&amp;hellip;Tn)，其中每个二叉树Ti(1 &amp;lt;= i &amp;lt;= n)中都有一个带权值为Wi的根节点，其左、右子树均为空。 在森林T中选取两个节点权值最小的子树，分别作为左、右子树构造一个新的二叉树，且置新的二叉树的根节点的权值为其左右子树上根节点权值之和。 在森林T中，用新得到的二叉树替代选取的两个二叉树。 重复2和3，直到T只包含一个树为止。这个数就是霍夫曼树。  平衡二叉树 它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
![âå¹³è¡¡äºåæ âçå¾çæç´¢ç»æ](../../images/Sun, 26 May 2019 235539.jpeg)
AVL   它的左子树和右子树都是平衡二叉树。
  左子树和右子树的深度之差的绝对值不超过1。
  B-树  所有叶子结点位于同一层，并且 不带信息。 树中每个节点最多有m个子树(即至多含有m-1个关键字)。 若根节点不是终端节点，则根节点子树[2,m]. 除根节点外其他非叶子节点至少有[m/2]个子树(即至少含有[m/2]-1个关键字)。 ![âb-æ âçå¾çæç´¢ç»æ](../../images/Sun, 26 May 2019 235747.jpeg)  B树 和 B+树的区别  B+树种所有叶子节点包含了全部关键字，即其他非叶子节点中的关键字包含在叶子节点中，而在B-树中，关键字是不重复的。 B+树中所有非叶子节点仅起到索引的作用  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/</guid>
      <description>78. Subsets Given a set of distinct integers, nums, return all possible subsets (the power set).Note: The solution set must not contain duplicate subsets.Example:
 Input: nums = [1,2,3] Output: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] 这种解法是 CareerCup 书上给的一种解法，想法也比较巧妙，把数组中所有的数分配一个状态，true 表示这个数在子集中出现，false 表示在子集中不出现，那么对于一个长度为n的数组，每个数字都有出现与不出现两种情况，所以共有 2n 中情况，那么我们把每种情况都转换出来就是子集了，我们还是用题目中的例子, [1 2 3] 这个数组共有8个子集，每个子集的序号的二进制表示，把是1的位对应原数组中的数字取出来就是一个子集，八种情况都取出来就是所有的子集了，参见代码如下
class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsets(int[] nums) { int n = nums.length; List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); for(int s=0;s&amp;lt; 1&amp;lt;&amp;lt;n;s++){ List&amp;lt;Integer&amp;gt; cur = new ArrayList&amp;lt;&amp;gt;(); for(int i=0;i&amp;lt;n;i++){ if((s &amp;amp; (1 &amp;lt;&amp;lt; i))&amp;gt;0){ cur.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E5%89%91%E5%80%BCoffer-%E5%88%B7%E9%A2%98%E9%9B%86%E5%90%88/%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E5%89%91%E5%80%BCoffer-%E5%88%B7%E9%A2%98%E9%9B%86%E5%90%88/%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>二叉树中和为某一值的路径 题目描述 输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)
import java.util.*; /** public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } */ public class Solution { public ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; result; public ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; FindPath(TreeNode root,int target) { result = new ArrayList&amp;lt;&amp;gt;(); find(root,target,new ArrayList&amp;lt;Integer&amp;gt;()); return result; } public void find(TreeNode root,int target,ArrayList&amp;lt;Integer&amp;gt; current) { if(root == null){ return; } if(root.val == target &amp;amp;&amp;amp; root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E5%89%91%E5%80%BCoffer-%E5%88%B7%E9%A2%98%E9%9B%86%E5%90%88/%E5%9B%9E%E6%BA%AF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E5%89%91%E5%80%BCoffer-%E5%88%B7%E9%A2%98%E9%9B%86%E5%90%88/%E5%9B%9E%E6%BA%AF/</guid>
      <description>字符串的排列 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。
可以画出一个递归树
每次递归都将当前的字母和之后的字母交换，然后不断深入。
import java.util.*; public class Solution { private ArrayList&amp;lt;String&amp;gt; result; private TreeSet&amp;lt;String&amp;gt; paths = new TreeSet&amp;lt;&amp;gt;(); public ArrayList&amp;lt;String&amp;gt; Permutation(String str) { result = new ArrayList&amp;lt;&amp;gt;(); if(str .equals(&amp;#34;&amp;#34;) ){ return result; } find(str,0); result.addAll(paths); return result; } public void find(String str,int index){ if(index == str.length()){ paths.add(str); return; } for(int i = index;i&amp;lt;str.length();i++){ char[] array = str.toCharArray(); char tmp = array[index]; array[index] = array[i]; array[i] = tmp; str = new String(array); find(str,index+1); } } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E5%9B%BE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E5%9B%BE/</guid>
      <description>133.Clone Graph Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors.
 Input: {&amp;quot;$id&amp;quot;:&amp;quot;1&amp;quot;,&amp;quot;neighbors&amp;quot;:[{&amp;quot;$id&amp;quot;:&amp;quot;2&amp;quot;,&amp;quot;neighbors&amp;quot;:[{&amp;quot;$ref&amp;quot;:&amp;quot;1&amp;quot;},{&amp;quot;$id&amp;quot;:&amp;quot;3&amp;quot;,&amp;quot;neighbors&amp;quot;:[{&amp;quot;$ref&amp;quot;:&amp;quot;2&amp;quot;},{&amp;quot;$id&amp;quot;:&amp;quot;4&amp;quot;,&amp;quot;neighbors&amp;quot;:[{&amp;quot;$ref&amp;quot;:&amp;quot;3&amp;quot;},{&amp;quot;$ref&amp;quot;:&amp;quot;1&amp;quot;}],&amp;quot;val&amp;quot;:4}],&amp;quot;val&amp;quot;:3}],&amp;quot;val&amp;quot;:2},{&amp;quot;$ref&amp;quot;:&amp;quot;4&amp;quot;}],&amp;quot;val&amp;quot;:1} Explanation: Node 1&#39;s value is 1, and it has two neighbors: Node 2 and 4. Node 2&#39;s value is 2, and it has two neighbors: Node 1 and 3. Node 3&#39;s value is 3, and it has two neighbors: Node 2 and 4.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E6%A0%88%E9%98%9F%E5%88%97%E5%A0%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E6%A0%88%E9%98%9F%E5%88%97%E5%A0%86/</guid>
      <description>232. Implement Queue using Stacks Implement the following operations of a queue using stacks.push(x)
 Push element x to the back of queue.pop() Removes the element from in front of queue.peek() Get the front element.empty() Return whether the queue is empty.  Example:
 MyQueue queue = new MyQueue(); queue.push(1); queue.push(2); queue.peek(); // returns 1 queue.pop(); // returns 1 queue.empty(); // returns false 这里我采用的是双栈法 入栈的时间复杂度是O(1)
出栈的时间复杂度是O(N)
我们采用一个top 去记录栈底部的数据，然后移动栈的时候当栈1的容量为0 这个元素就是top
class MyQueue { private Stack&amp;lt;Integer&amp;gt; stack1; private Stack&amp;lt;Integer&amp;gt; stack2; private int top = -1; /** Initialize your data structure here.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/</guid>
      <description>\2. 买苹果最少袋子数-贪心法
\3. 线性排列正方形的最少涂染数-辅助数组
\4. N阶方阵中最大正方形边长-辅助数组
\5. 指定概率数字生成函数-构造概率函数，数学题
6.给定非负整数n能形成的二叉树结构数目-左右子树加上根节点，递归或者动态规划
7.构成完整括号字符串的最少添加括号数-2个变量计数
8.差值为k的去重数字对-哈希
9.最大magic操作数-贪心
10.可以转换的不同字符串的个数-动态规划
11.括号序列的深度-动态规划
12.栈的升序排序-栈
13.青草游戏-打表
14.根节点到叶节点权值最大-树形dp
15.打包机器-贪心
16.zipzap打印矩阵-模拟
17.螺旋打印矩阵-模拟
18.顺时针选择矩阵-模拟
19.有序二维数组找书-模拟
20.拼接出长度n的最小操作数-分类讨论
21.找出现次数最多前k个字符串-堆
22.狗猫队列-队列哈希
23.返回栈中最小元素-栈
24.栈队列转换-栈、队列
25.动态规划空间压缩
26.容器灌水-栈
27.左右部分最大绝对值之差-队列
28.旋转词-kmp算法
29.附加题-斐波那契数列矩阵乘法
30.达标字符串数量-斐波那契数列
31.删除木棒数-贪心、斐波那契数列
32.调整数列两两相乘为4的倍数-思维题
33.判断字符串是否为整数-正则表达式
34.TopKRecord结构-背包
35.放进背包的零食种数-动态规划
36.牛牛找工作-贪心
37.画目录结构-字母多叉树
38.搜索二叉树转换有序双向列表-思维题
39.最大搜索二叉子树的节点个数-树形结构
40.返回后序遍历-递归
41.安置路灯-贪心，动态规划
42.帖子最高分数-动态规划
43.子矩阵的最大累计和-思维题
44.数字用中文表示-模拟
45.找到[1,n]中所有未出现在A中的整数-数组
46.神奇的数列-思维题
47.送C币-贪心
48.求完全二叉树节点的个数-递归
49.cc直播运营活动-bfs
50.最长递增子序列问题-动态规划
51.最大子数组异或和-动态规划
52.express组合成desired的方案数-区间动归
53.字典序问题-暴力
54.无重复字符子串中最长的长度-滑动窗口
55.最小编辑代价-动态规划
56.删字符-贪心
57.字符串变换-bfs
58.可变更缓存结构-哈希、双向链表
59.求一条直线最多能穿过多少个点-枚举
60.最少的跳跃次数跳到最后一个数-贪心
61.两个数相加和最大的前k个-思维题
62.数组分成4部分-二分答案
63.判断字符串是否为交错组成-动态规划
64.找丑数-模拟
65.需要排序的最短子数组长度-思维题
66.最小不可组成和-动态规划
67.组成区间缺少的数-动态规划</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E8%B2%AA%E5%BF%83/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E8%B2%AA%E5%BF%83/</guid>
      <description>455. Assign Cookies Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj &amp;gt;= gi, we can assign the cookie j to the child i, and the child i will be content.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/</guid>
      <description>92. Reverse Linked List II Reverse a linked list from position m to n. Do it in one-pass.
Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, m = 2, n = 4 Output: 1-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;5-&amp;gt;NULL 代码:
class Solution { public ListNode reverseBetween(ListNode head, int m, int n) { if(head == null) { return null; } ListNode dummy = new ListNode(0); dummy.next = head; ListNode pre = dummy; for(int i = 0 ; i&amp;lt;m-1;i++){ pre = pre.next; } ListNode start = pre.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/bigdata%E5%A4%A7%E6%95%B0%E6%8D%AE/bloomfilter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/bigdata%E5%A4%A7%E6%95%B0%E6%8D%AE/bloomfilter/</guid>
      <description>算法描述 一个empty bloom filter是一个有m bits的bit array，每一个bit位都初始化为0。并且定义有k个不同的hash function，每个都以uniform random distribution将元素hash到m个不同位置中的一个。在下面的介绍中n为元素数，m为布隆过滤器或哈希表的slot数，k为布隆过滤器重hash function数。
添加一个元素 用k个hash function 将hash得到的bloom filter中的k个bit位 置为1。
查询元素是否存在 用k个hash function 将他的hash得到k个bit位，如果任意一位为0，则这个元素必不存在。
误判 当add 的元素过多，n/m（n元素数目 m 是bloom filter的bit数目） 过大，会导致false positive 此时就需要重新组建filter，但这种情况相对少见。
优势 时间 add 和 query 时间复杂度只有 O(k)
空间 对于一个有1%误报率和一个最优k值的布隆过滤器来说，无论元素的类型及大小，每个元素只需要9.6 bits来存储。
当 -1/m 很大 并且趋于0的时候误判率会降低，n降低也会使误判率降低。
输入 1000w 误判率1% 计算占用空间9000w bit 100M 这样 并且空间占用率50% m = 9000w n = 1000w
hashfunction 0.7*9 = 7
空间占用估计 ： k=0.7*(l/n) # 约等于 f=0.6185^(l/n) # ^ 表示次方计算，也就是 math.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/database%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/database%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/</guid>
      <description>索引的类型: B-Tree 索引 InnoDB 使用的是B+Tree
根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下查找。通过要查找的值来找到合适的指针进入下层节点。
假设有如下数据表
create table people( last_name varchar(50) not null, first_name varchar(50) not null, dob date not null, gender enum(&amp;#39;m&amp;#39;,&amp;#39;f&amp;#39;) not null, key(last_name,first_name,dob) ); 对于表中的每一行数据，索引中包含了last_name,first_name 和 dob 列的值。 显示了该索引是如何组织数据存储的。
有效使用索引：
 全值匹配 匹配最左前缀 匹配列前缀 匹配范围值 精确匹配某一列并范围匹配另外一列 值访问索引  B-Tree 索引的限制：
 如果不是按照索引的最左侧开始查找，就无法使用索引。 不能跳过索引中的列，如果要查找姓名为 A 生日在 B 的人是只能使用索引的第一列。  B-树  内部节点:含有与页相关联的页的副本 外部节点:含有指向实际数据的引用 哨兵键:小于其他所有键，一开始B-树只含有
一个根节点，节点初始化出的就是哨兵节点  查找和插入 查找:在可能含有被查找键的唯一子树中进行一次递归的
搜索
插入: 如果被插入的节点变成一个溢出的节点
递归调用不断向上调用分裂溢出的节点
为什么使用B-Tree / B+Tree 主要和硬盘的存取原理有关。 硬盘不是按需读取的，每次读取都会预读一些。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/database%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/database%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis/</guid>
      <description>安装redis 创建redis目录 mkdir redis
安装wget yum install -y wget
设置登陆密码 这是修改redis的配置文件 vim /etc/redis/redis.conf
找到requirepass
修改密码。
重启redis
/etc/init.d/redis-server restart
scrapy爬虫报错 2018-12-23 14:03:12 [twisted] CRITICAL: Unhandled Error Traceback (most recent call last): File &amp;#34;/home/ubuntu/.local/lib/python3.5/site-packages/scrapy/commands/crawl.py&amp;#34;, line 58, in run self.crawler_process.start() File &amp;#34;/home/ubuntu/.local/lib/python3.5/site-packages/scrapy/crawler.py&amp;#34;, line 291, in start reactor.run(installSignalHandlers=False) # blocking call File &amp;#34;/home/ubuntu/.local/lib/python3.5/site-packages/twisted/internet/base.py&amp;#34;, line 1267, in run self.mainLoop() File &amp;#34;/home/ubuntu/.local/lib/python3.5/site-packages/twisted/internet/base.py&amp;#34;, line 1276, in mainLoop self.runUntilCurrent() --- &amp;lt;exception caught here&amp;gt; --- File &amp;#34;/home/ubuntu/.local/lib/python3.5/site-packages/twisted/internet/base.py&amp;#34;, line 902, in runUntilCurrent call.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/fp%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/fp-in-scala/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/fp%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/fp-in-scala/</guid>
      <description>什么是函数式编程?
函数式编程：只用纯函数来构造程序。
什么是纯函数?
没有副作用的函数。
什么是副作用?
一个带有副作用的函数，不仅会简单的返回一个值，而且会干一些其他的事情。
非严格求值
def getOrElse[B &amp;gt;: A](default: =&amp;gt; B): B = this match{ case None =&amp;gt; default case Some(x) =&amp;gt; x } 可以看到如果为 None 的情况下计算 default 的值，否则返回内部的值
这样能提高性能</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/fp%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/fp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/fp%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/fp/</guid>
      <description>第一公民 函数 闭包  lexical scope   高阶函数 柯里化  random (1,10)
![image-20191129190758229](/Users/xiantang/Library/Application Support/typora-user-images/image-20191129190758229.png)
![image-20191129190236925](/Users/xiantang/Library/Application Support/typora-user-images/image-20191129190236925.png)
闭包有一些前置知识需要知道
lexical scope
![image-20191129191234476](/Users/xiantang/Library/Application Support/typora-user-images/image-20191129191234476.png)
为什么要有 lexical scope？
![image-20191129191724741](/Users/xiantang/Library/Application Support/typora-user-images/image-20191129191724741.png)
因为你想啊 如果变量是动态的 内部的x 会被外边定义的x 影响的话，那filter 函数将会失效
![image-20191129192023173](/Users/xiantang/Library/Application Support/typora-user-images/image-20191129192023173.png)
当你用fold来实现一些更加具象的东西的时候
![image-20191129193025588](/Users/xiantang/Library/Application Support/typora-user-images/image-20191129193025588.png)
你可以看到上面两个函数都是使用了私有数据 以f3 为例 hi, lo 的值在函数定义时候已经被设置好了，当传入的时候，以及运算的时候都不会被外部变量影响。
因为这个所以能够让这些 fold map filter 更有力量。
![image-20191129190608208](/Users/xiantang/Library/Application Support/typora-user-images/image-20191129190608208.png)
![image-20191129190638068](/Users/xiantang/Library/Application Support/typora-user-images/image-20191129190638068.png)
柯里化
![image-20191129194251416](/Users/xiantang/Library/Application Support/typora-user-images/image-20191129194251416.png)
![image-20191129194526611](/Users/xiantang/Library/Application Support/typora-user-images/image-20191129194526611.png)
![image-20191129194814552](/Users/xiantang/Library/Application Support/typora-user-images/image-20191129194814552.png)
currying 的好处是
你可以缺省这些参数
采用 sorted 3
他返回的是一个 fn y=&amp;gt; fn z=&amp;gt; z&amp;gt;=y andalso y&amp;gt;=3 的函数</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/fp%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/how-future-work/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/fp%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/how-future-work/</guid>
      <description>object Future { def apply[T](body: =&amp;gt; T)(implicit executor: ExecutionContext): Future[T] = unit.map(_ =&amp;gt; body) } a Java framework for supporting a style of parallel programming in which problems are solved by (recursively) splitting them into subtasks that are solved in parallel, waiting for them to complete, and then composing results
1.INTRODUCTION
The fork operation starts a new parallel fork/join subtask.
The join operation causes the current task not to proceed until the forked subtask has completed.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/fp%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8Escala/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/fp%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8Escala/</guid>
      <description>背景: 刚来到以scala为技术栈的公司的时候，配置了半天环境，然后终于将项目起了起来，发现里面的代码很奇怪，没有任何循环，数据的操作是一个函数套着一个函数，十分令人疑惑，于是借着业务需求和这股好奇劲开始学习关于scala的内容。
目标:  熟练运用项目中的异步操作 Future 变换 (同步思维转异步) 熟悉 Play 框架能够熟练的翻文档解决问题 熟练运用高阶函数 map flatMap 等操作  阶段 1:能写 Scala 这个阶段比较容易达到，就是首先需要阅读 《Scala编程》前几章 或者 推特scala课堂 ，来了解scala的基本语法。但是在这个阶段仍然会有很多的坑，基本是在 IDEA 的提示 与 爆红下才能勉强的写代码。
阶段2: 知道函数式编程是什么东西 当你差不多写了半个月 Scala 之后，仍然好奇函数式编程是什么东西，这个时候你就可以去学习一些关于函数式编程的知识了，我的线路是先学习了 programming-languages 这门入门课程，主要讲了一些关于函数式编程的基础知识,包括但不限于 闭包 高阶函数 尾递归 代数类型。 虽然语言不是Scala 但是这门课为我之后的函数式编程打下了一定的基础。 如果你在这门课上认真的完成了作业，后面的路会通畅很多。
阶段3:再深入的了解 到这个时候，你一定会听到一本十分有名的书《Scala 函数式编程》 这本书，很有可能在你没经历前几个阶段的时候，你就看了，但是发觉里面的内容十分抽象，便放弃了。现在你就可以大胆的去看它了，可以无痛的看到第六章。
再在下面，就会被更抽象的 Monad Factor 等概念所迷惑。
阶段4:持续学习基础 上面的阻塞其实还是因为对基础知识不够扎实，所以还是需要进一步的学习，这里推荐 Scala 语言作者的课程 Functional Programming Principles in Scala . 因为不是免费的，所以需要付费或者采用奖学金（咸鱼）来免费学习。这门课程虽然不及上面的 programming-languages 课程，但是比较困难的习题还是能提升FP的水平的。
阶段5:参与社区 这个时候你就可以继续去看 《Scala 函数式编程》 这本书了，因为你看完了上面的两门全英文课程所以英文也不会再惧怕就可以参与社区了，这里推荐几个比较好的社区，曾经给我过帮助的社区 https://gitter.im/scala/scala. https://gitter.im/akka/akka , 如果对开源有兴趣，就可以给 akka 或者 Play 修复BUG了。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/framework%E6%A1%86%E6%9E%B6/spring/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/framework%E6%A1%86%E6%9E%B6/spring/</guid>
      <description>1.step1-最基本的容器 IoC最基本的角色有两个：容器(BeanFactory)和Bean本身。这里使用BeanDefinition来封装了bean对象，这样可以保存一些额外的元信息。测试代码：
// 1.初始化beanfactory BeanFactory beanFactory = new BeanFactory(); // 2.注入bean BeanDefinition beanDefinition = new BeanDefinition(new HelloWorldService()); beanFactory.registerBeanDefinition(&amp;#34;helloWorldService&amp;#34;, beanDefinition); // 3.获取bean HelloWorldService helloWorldService = (HelloWorldService) beanFactory.getBean(&amp;#34;helloWorldService&amp;#34;); helloWorldService.helloWorld(); 对于 BeanFactory 我们使用的容器是 ConcurrentHashMap
public class BeanFactory { /** * Spring 通过线程池的方式来publishEvent ApplicationListener的实现类是在线程中运行的 */ private Map&amp;lt;String, BeanDefinition&amp;gt; beanDefinitionMap = new ConcurrentHashMap&amp;lt;&amp;gt;(); public Object getBean(String name){ return beanDefinitionMap.get(name).getBean(); } public void registerBeanDefinition(String name, BeanDefinition beanDefinition) { beanDefinitionMap.put(name, beanDefinition); } } 2.step2-将bean创建放入工厂 step1中的bean是初始化好之后再set进去的，实际使用中，我们希望容器来管理bean的创建。于是我们将bean的初始化放入BeanFactory中。为了保证扩展性，我们使用Extract Interface的方法，将BeanFactory替换成接口，而使用AbstractBeanFactory和AutowireCapableBeanFactory作为其实现。&amp;ldquo;AutowireCapable&amp;quot;的意思是“可自动装配的”，为我们后面注入属性做准备。
// 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/goal%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/2018%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/goal%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/2018%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</guid>
      <description>到年底啦，稍微写一点总结总结一下这个2018年。
这一年有失去也有获得吧。失去是一段没有结果的感情的失败，获得则是整个人质的提升。
失去的就让他过去了，我也不想再多提什么。
我们来谈谈收获吧。
收获主要分为三个方面，身体，技术和金钱。
先谈身体吧，今年年初的时候，也就是大二下刚开始的时候，坚持每天去操场去跑个几圈，有时就算是下着🌧️我们也会去跑一下,但是跑着跑着就只剩下我一个人来，遂就作废。之后没怎么锻炼，每天在实验室呆到10点，感觉身体也有点愚钝了。之后就是实习，实习的时候尝试去过一天健身房，但是离住的地方实在太远了，所以也就作废。其实是因为太懒 但是在内心还是想去健身房持久不断的锻炼的。遂在这个学期的10月份办了张健身卡，一开始是自己一个人锻炼的，而且有时候还有技术不够格的私教忽悠我办卡，我每次都是用贫穷来拒绝❌。不过自己的确没有很认真在练，之后就是10月中旬，涛哥开始带我了（实验室队友），我才感觉到这才是健身，每次看到涛哥表情狰狞的样子，我就想我也得努力一点，一直坚持到年底，感觉肩膀结实了一点，胳膊也粗了一些，也不会有坐太久虚了的情况。尽管现在有了一点点成果，但是我知道，健身这种东西是以年为单位的，肌肉是需要慢慢雕刻的。
再谈技术，今年最大的变化是主力开发语言的改变，从Python转到了Java,其实是一直想转变的，明显感受到做爬虫和Python后端的前途不明朗，我主要想发展的方向是爬虫，但是渐渐觉得爬虫，作为第二技能会比较好一点。中间真的经历了很多纠结，但是还是作出了决定。对于Java这门语言其实我也不算厌恶,因为这是一门很优秀并且稳定的语言，有着非常好的生态，可能也因为我不能十分好的驾驭Python吧。对于Java的学习，其实我对于这门庞大的语言还是十分的不熟悉的，希望自己能够从基础开始，然后慢慢去了解后端的体系结构吧。我想对未来的我说，后端不只是Java，一个优秀的后端工程师是不会被语言给限制住的。
关于金钱，今年的理解是，只要够用就行。年初因为变故，辞了理货员的兼职，所以收入会比之前少了一些，但是在开学之后，就开始接爬虫外包，没有做的很拼命，正好和自己做理货员的工资相抵消，但是那段时间对于我的技术的成长是很大的，让我更加熟悉了Python这门语言。今年的爬虫实习，干了暑假两个月，拿了6K，伤心的是这个6K被我在杭州的开销相抵消了大部分，实在是有点真实。不过回到学校，我换了一台手机，应该能撑过剩下两年8⃣️。最近前公司的项目老大找我做爬虫，我要了很高的价格 因为自己其实不是很想做，尝试了做了一下，发现其实工作量比想象中的大很多，遂放弃。也和这段开头说的相同,够用就行，能够学习自己喜欢的技术，并且做自己想要做的项目，其实也是一件很快乐的的事情。一直做自己喜欢的事情，💰会随之而来的。
我的2018就是这样，2019的目标先不写出来了，只希望能变成更好的自己。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/goal%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/2019%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/goal%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/2019%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</guid>
      <description>又到年底了，再总结总结我的2019吧。
今天正好也是和失落情绪撕咬的一天。
这一年是我的大三秋招年，也就是需要找工作，为资本家工作的一年。
谈谈失去和获得吧。
分为三点讲吧，怕自己说不清楚事情。
先谈身体吧，其实上半年在学校的时候，有经常锻炼的习惯，但是一到下半年准备秋招的时候，索性锻炼都没去锻炼了。到现在身体越来越差，终于意识到，身体是最重要的东西，比任何东西都弥足珍贵，也许我必须在20年把锻炼身体放在第一位，而不是为了什么所谓的绩效，导致身体垮掉，因为身体健康能保证你之后的生命的持续输出，如果身体垮了，在病床上花的钱很快能将你的积蓄清空。
再谈技术，因为经历秋招，那写丧心病狂的面试题之后，基础更加牢固了。原来也打算以 Java 作为自己的第一语言，但是秋招进了一家以 scala 技术栈的公司
// TODO xxx</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/goal%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/7-3%E5%88%B07-4%E5%8F%B7%E8%A7%84%E5%88%92/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/goal%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/7-3%E5%88%B07-4%E5%8F%B7%E8%A7%84%E5%88%92/</guid>
      <description>深入理解JVM 7/3-7/13 什么是栈帧？ sync 锁降级？ JIT 编译器的发展？ 逃逸分析？ string intern 方法？     tiny Spring 源码阅读 7/14-7/24 为什么要用concurrentHashMap 做 容器     Java 并发编程的艺术 7/24-8/01     公司源码 消息中间件怎么用 用在哪里 分布式锁 怎么用 场景  分布式锁？ setnx()函数 ？ Redis 连接池   负载均衡算法 读写分离 主备 数据库 限权管理怎么做的    10000w行log 查指定时间
sed -n &amp;lsquo;/2015-05-04 09:25:55/,/2015-05-04 09:28:55/&amp;lsquo;p /home/wwwlogs/access.log
星期一/星期二/星期四
10-&amp;gt;12 吃饭 这段时间 看 JVM Spring</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/goal%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/9%E6%9C%8828-%E6%97%A5%E5%88%B010%E6%9C%8811%E6%97%A5%E8%A7%84%E5%88%92/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/goal%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%92/9%E6%9C%8828-%E6%97%A5%E5%88%B010%E6%9C%8811%E6%97%A5%E8%A7%84%E5%88%92/</guid>
      <description>10：00 -&amp;gt;11：00 阅读Tomcat 源码 跟着书写每天25页 必须做总结
13:30 -&amp;gt; 17:00 阅读源码结束
17:00 -&amp;gt; 20:00 休息恰饭
20:00 -&amp;gt; 22:00 做一下剑指offer 每日3题 到11日的时候至少54题 每做一道必须更新题解
每日必须更新完成的数目
9月 28 日 8点回到寝室并且收拾东西
9月29日 因为要回家不算
9月28日 日报
 完成最近15天的短期Tomcat &amp;amp; 算法学习规划 已完成对 类加载器章节的复习。 10 页 25/280 HTTP 45 / 280 今天看了 35 页  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/classloader/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/classloader/</guid>
      <description>实现容器热加载机制 什么是双亲委任模型？ 双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派父类加载器去完成。每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个请求（他的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。
从Java 开发人员的角度来看，类加载还可以再细致一些，绝大部分Java 程序员都会使用以下 3 种系统提供的类加载器:
 启动类加载器（Bootstrap ClassLoader）：这个类加载器复杂将存放在 JAVA_HOME/lib 目录中的，或者被-Xbootclasspath 参数所指定的路径种的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录下也不会重载）。 扩展类加载器（Extension ClassLoader）：这个类加载器由sun.misc.Launcher$ExtClassLoader实现，它负责夹杂JAVA_HOME/lib/ext 目录下的，或者被java.ext.dirs 系统变量所指定的路径种的所有类库。开发者可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher$AppClassLoader 实现。由于这个类加载器是ClassLoader 种的getSystemClassLoader方法的返回值，所以也成为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库。开发者可以直接使用这个类加载器，如果应用中没有定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。  双亲委派模型的好处 双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派父类加载器去完成。每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个请求（他的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。
双亲委派是如何实现的呢？ protected synchronized Class&amp;lt;?&amp;gt; loadClass(String name, boolean resolve) throws ClassNotFoundException{ // First, check if the class has already been loaded  Class c = findLoadedClass(name); if (c == null) { try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found  // from the non-null parent class loader  } if (c == null) { // If still not found, then invoke findClass in order  // to find the class.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/idea/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/idea/</guid>
      <description>在 Intelij IDEA 中修改 maven 为国内镜像 国内镜像：阿里 打开 IntelliJ IDEA-&amp;gt;Settings -&amp;gt;Build, Execution, Deployment -&amp;gt; Build Tools &amp;gt; Maven 或者直接搜索 maven 具体如下图所示： 而一般情况下在 c:\Users\xx.m2 \ 这个目录下面没有 settings.xml 文件，我们可以新建一个，settings.xml 文件下的内容是：直接粘贴复制保存在上图所示的目录下面就可以了. 需要注意的是，需要点击上图所示右下角的 override。
&amp;lt;settings xmlns=&amp;#34;http://maven.apache.org/SETTINGS/1.0.0&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:schemaLocation=&amp;#34;http://maven.apache.org/SETTINGS/1.0.0 https://maven.apache.org/xsd/settings-1.0.0.xsd&amp;#34;&amp;gt; &amp;lt;mirrors&amp;gt; &amp;lt;mirror&amp;gt; &amp;lt;id&amp;gt;alimaven&amp;lt;/id&amp;gt; &amp;lt;name&amp;gt;aliyun maven&amp;lt;/name&amp;gt; &amp;lt;url&amp;gt;http://maven.aliyun.com/nexus/content/groups/public/&amp;lt;/url&amp;gt; &amp;lt;mirrorOf&amp;gt;central&amp;lt;/mirrorOf&amp;gt; &amp;lt;/mirror&amp;gt; &amp;lt;/mirrors&amp;gt; &amp;lt;/settings&amp;gt; 如果是 linux 系统，操作过程基本相同，只是 settings.xml 文件的存放路径不一样，不过都可以通过上面截图所示的页面中查到。
idea 常用快捷键 ctrl+N 生成代码
ctrl+shift+A 命令全搜索.
This is almost always followed by Ctrl + Alt + Left to get back to where I was (Ctrl + Alt + Right works to “go forward” again).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/javacollection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/javacollection/</guid>
      <description>TODO  集合类的各个使用环境  Java容器 集合体系结构 集合作为一个容器，可以存储多个元素,java提供了多种集合类。将集合类中共性的内容，不断向上抽取，最终形成了集合的体系结构。 Map和Set接口继承Collection List继承ListIterator和Collection Collection和ListIterator继承Iterator
List和队列的区别 Queue接口与List、Set同一级别，都是继承了Collection接口。 LinkedList实现了Queue接口，Queue接口窄化了LinkedList其他方法的访问，就是如果接口参数是Queue的话，只能访问Queue定义的方法。
阻塞队列 试图向一个满的队列或者一个空的阻塞队列存入一个值的时候会阻塞线程。在多线程合作的时候阻塞线程是一个很好的工具。
HashMap 和 HashTable 还有ConcurrentHashMap的区别 以及扩容机制 HashTable 是传统的集合类 已经过时了，在Java4时候被重写了实现了Map接口。
 相同:  都实现了Map接口   不同:  线程的安全性:HashMap不是synchronized的，HashTable是线程安全的。 多个线程可以共享HashTable,没有正确同步的话，多个线程是无法贡献HashMap的。Java5 提出的ConcurrentHashMap是HashTable的替代，共享性更好。 HashMap可以接受null的key和value,HashTable不行。 HashMap的迭代器是fail-fast的迭代器，但是Hashtable的enumerator迭代器不是fail-fast的。当有其他线程更改了HashMap的结构，就会抛出ConcurrentModificationException。由于在同一时刻只有一个线程修改ConcurrentHashMap所以不需要抛出这个异常。 Hashtable 线程安全使用的是synchronized，因为这个是JVM关键字，是重型操作，所以在单线程下还是HashMap效率高。ConcurrentHashMap使用的是CAS技术，也就是乐观锁。当多个线程需要修改同一个变量时候只有其中一个线程能更新，其他线程都失败，失败的线程不会挂起，而是告知这次竞赛失败。先获取key的hashCode,如果是空的就初始化，初始化的时候如果sizeCtl被修改就直接yield当前线程。如果CAS竞赛成功就创建新的table。    重写equals() 传什么参  自反性：对于任意的引用值x，x.equals(x)一定为true。  对称性：对于任意的引用值x 和 y，当x.equals(y)返回true时， y.equals(x)也一定返回true。  传递性：对于任意的引用值x、y和ｚ，如果x.equals(y)返回true， 并且y.equals(z)也返回true，那么x.equals(z)也一定返回true。  一致性：对于任意的引用值x 和 y，如果用于equals比较的对象信息没有被修 改，多次调用x.equals(y)要么一致地返回true，要么一致地返回false。  非空性：对于任意的非空引用值x，x.equals(null)一定返回false。   HashMap源码解析 HashMap 主要用来存放键值对，它基于哈希表的Map接口实现，是常用的Java集合之一。
 JDK1.8 之前由数组和链表组成，链表主要为了解决冲突 JDK1.8 之后在解决hash冲突的时候采取了较大变化，链表长度大于8链表转换为红黑树（log n）。 初始容量16，尽量先预估自己的数据量来设置初始值。  JDK1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/javaconcurrent/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/javaconcurrent/</guid>
      <description>TODO  多线程的通信，同步方式 volatile和synchronized的区别 乐观锁与悲观锁? 乐观锁它是怎么实现的? 悲观锁呢?  Java并发 乐观锁 CAS compare and swap(比较与交换)，是一种有名的无锁算法。不用锁的情况下实现多线程的变量同步，在没有线程阻塞 的情况下实现变量同步，也叫非阻塞同步。当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。适用于读较多的情况。 三个操作数:
 需要读写的内存值 V 进行比较的值（预期值） A 拟写入的新值 B 当且仅当预期值和内存值相等，将内存V修改为B，否则什么都不做。一般来说是一个自旋的操作，不断的重试。 CAS, CPU指令，在大多数处理器架构，包括IA32、Space中采用的都是CAS指令，CAS的语义是“我认为V的值应该为A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际为多少”，  悲观锁  资源共享只给一个线程，其他线程阻塞，用完在给其他线程。 适用于写较多的情况。  synchronized 使用场景 线程具有五大状态:
 新建状态：新建线程对象，并没有调用start()方法之前。 就绪状态：调用start()方法之后线程就进入就绪状态，但是并不是说只要调用start()方法线程就马上变为当前线程。 运行状态：线程被设置为当前线程，开始执行run()方法。就是线程进入运行状态 阻塞状态：线程被暂停，比如说调用sleep()方法后线程就进入阻塞状态 死亡状态：线程执行结束  锁类型:
 可重入锁（synchronized和ReentrantLock）：在执行对象中所有同步方法不用再次获得锁 可中断锁（synchronized就不是可中断锁，而Lock是可中断锁）：在等待获取锁过程中可中断 公平锁（ReentrantLock和ReentrantReadWriteLock）： 按等待获取锁的线程的等待时间进行获取，等待时间长的具有优先获取锁权利 读写锁（ReadWriteLock和ReentrantReadWriteLock）：对资源读取和写入的时候拆分为2部分处理，读的时候可以多线程一起读，写的时候必须同步地写  Synchronized与Lock的区别  synchronized关键字 Lock是接口 Synchronized获取锁的线程执行完同步代码，释放锁，线程执行发生异常，jvm会让线程释放锁。Lock 在finally中必须释放锁，不然容易造成死锁。 Synchronized无法判断锁状态，Lock可以判断。 synchronized 少量同步，Lock可以提高线程进行读操作的效率（读写分离）     类型 synchronized Lock     存在层次 Java的关键字，在jvm层次 一个类   锁的释放 获取锁执行完成同步代码，执行发生异常，会有一个monitorexit 来退出 必须在finally释放锁   锁的获取 假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待 分情况而定，Lock有多个锁获取的方式，具体下面会说道，大致就是可以尝试获得锁，线程可以不用一直等待   锁状态 无法判断 可以判断   锁类型 可重入 不可中断 非公平 可重入 可判断 可公平（两者皆可）    synchronized 的锁优化 锁的升级策略: 偏向锁-&amp;gt;轻量级锁-&amp;gt;重量级锁 偏向锁、轻量锁的状态转换以及对象MarkWord的关系</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/javaio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/javaio/</guid>
      <description>Java IO StringBulider 和StringBuffer区别  String ：字符串常量 StringBuffer 字符串变量(线程安全) StringBuilder 字符串变量(非线程安全)  StringBuilder 和 StringBuffer 还有 String 的区别
 String是不可变对象 public final class String,每次改变等于生成了一个新的String对象。 StringBuffer是可变对象，每次改动都会对StringBuffer 对象本身进行改动。在某些情况下String 的改动被JVM解释称StringBuffer的拼接。 StringBuffer是线程安全的，一个类似String的字符串缓存区，不能修改。 因为可以安全的用于多个线程，所以在实例上的操作就想是串行的。  append():加入到字符缓冲区的末尾。 insert():替换指定位置   StringBuilder是StringBuffer的替换，在字符串缓冲区被单个线程使用的时候，优先使用该类。  NIO 多路复用模型 一个线程去轮询多个socket的状态，只有当socket真正有读写事件的时候，才会真正调用实际的IO操作。
另外多路复用 IO 为何比非阻塞 IO 模型的效率高是因为在非阻塞 IO 中，不断地询问 socket 状态 时通过用户线程去进行的，而在多路复用 IO 中，轮询每个 socket 状态是内核在进行的，这个效 率要比用户线程要高的多。
Selector Selector 类是 NIO 的核心类，Selector 能够检测多个注册的通道上是否有事件发生，如果有事 件发生，便获取事件然后针对每个事件进行相应的响应处理。
流与块的比较 面向块的IO系统以块的形式处理数据。每一个操作都在一步中产生或消费一个数据块。按块要比按流快的多，但面向块的IO缺少了面向流IO所具有的有雅兴和简单性。
Channel 是对于原IO流的模拟，来源和目的对象都必须通过Channel。Buffer实质是一个容器对象，发送给Channel 的所有对象都必须放到Buffer中。
同步、异步、阻塞与非阻塞  同步:就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。 异步:是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。  Linux IO 模型 同步阻塞 IO（blocking IO） 用户空间的应用程序执行一个系统调用，会导致程序阻塞，什么都不干，直到数据准备好。 同步非阻塞 IO（nonblocking IO） 同步非阻塞就是 “每隔一会儿瞄一眼进度条” 的轮询（polling）方式。 缺点:任务完成的响应延迟增大了，每隔一段时间才会轮询义词 read 操作，可能任务在两次轮询之间的任意时间完成。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/jvm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/jvm/</guid>
      <description>反射 Java 反射机制：在程序运行的时候，对于任意的一个类，都能够知道这个类的所有属性和方法，对于任意一个对象可以调用它的任意属性和方法这种动态获取信息以及动态调用对象的方法的功能叫做Java反射(reflect)。
Jvm Java 技术体系  Java 程序设计语言 各种平台上的Java 虚拟机 Java API 类库 来自商业机构和开源社区的第三方Java类库  Java程序设计语言、Java虚拟机、Java API类库这三部分统称为JDK（Java Development Kit）
Java API类库中的Java SE API子集 [1] 和Java虚拟机这两部分统称为JRE（Java Runtime Environment）
 Java ME（Micro Edition）：支持Java程序运行在移动终端（手机、PDA）上的平台，对 Java API有所精简，并加入了针对移动终端的支持，这个版本以前称为J2ME。 Java SE（Standard Edition）：支持面向桌面级应用（如Windows下的应用程序）的Java 平台，提供了完整的Java核心API，这个版本以前称为J2SE。 Java EE（Enterprise Edition）：支持使用多层架构的企业应用（如ERP、CRM应用）的 Java平台，除了提供Java SE API外，还对其做了大量的扩充 [3] 并提供了相关的部署支持，这 个版本以前称为J2EE。  混合语言：
多语言混合编程正成为主流，每种语言都可以针 对自己擅长的方面更好地解决问题。试想一下，在一个项目之中，并行处理用Clojure语言编 写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完 成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像 使用自己语言的原生API一样方便 [1] ，因为它们最终都运行在一个虚拟机之上。
64 位虚拟机：
Java程序运行在64位虚拟机上需要付出比较大的额外代价：首先是内 存问题，由于指针膨胀和各种数据类型对齐补白的原因，运行于64位系统上的Java应用需要 消耗更多的内存，通常要比32位系统额外增加10%～30%的内存消耗；
普通对象指针压缩:
（-XX：+UseCompressedOops，这个参数不建议显式设 置，建议维持默认由虚拟机的Ergonomics机制自动开启）
Java 内存区域 与 内存溢出异常 程序计数器 程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线 程所执行的字节码的行号指示器。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/quartz%E9%87%8D%E5%A4%8D%E8%B0%83%E5%BA%A6%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/quartz%E9%87%8D%E5%A4%8D%E8%B0%83%E5%BA%A6%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</guid>
      <description>序列化问题 行锁保证线程安全 类加载 为什么事务就能保证安全了？  触发JOB fire
TRIGGER_STATE 是当前trigger 的状态 PREV_FIRE_TIME 是上次触发的时间
locks表 Quart 支持分布式，也就是会存在多个线程同时抢占资源的情况处理这种状况。
protected &amp;lt;T&amp;gt; T executeInNonManagedTXLock( String lockName, TransactionCallback&amp;lt;T&amp;gt; txCallback, final TransactionValidator&amp;lt;T&amp;gt; txValidator) throws JobPersistenceException { boolean transOwner = false; Connection conn = null; try { if (lockName != null) { // If we aren&amp;#39;t using db locks, then delay getting DB connection  // until after acquiring the lock since it isn&amp;#39;t needed.  if (getLockHandler().</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/%E7%AC%94%E7%BB%8F/360-%E7%AC%94%E8%AF%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/%E7%AC%94%E7%BB%8F/360-%E7%AC%94%E8%AF%95/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/kyligence%E5%AE%9E%E4%B9%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/kyligence%E5%AE%9E%E4%B9%A0/</guid>
      <description>一面
问的十分基础
java 的所有基本类型
String 是可变类型吗 String的实现有什么不同
volatile 的几个作用
final 的作用
有什么问题？
作为程序员在Kyligence 的一天是怎么样的？
然后聊天
二面
讲一下你对泛型的理解
能不能声明一个 Lista = new ArrayList并且 B 继承 A
三次握手 为什么要有三次握手
基于 TCP 设计一个文件上传的协议（emmm 爱奇艺三面问到)
垃圾回收机制 讲一个你比较熟悉的垃圾回收器
手撕代码（纸上）
三个线程ABC 反复交替打印 A B C 撕了
实现一个计算器 没有括号 两个栈就完事了 撕了
有什么问题？
贵公司如何做code review的？
三面
leader 好像不知道我来面的什么岗
我随口说了个实习生
我人都傻了
然后让我等offer邮件
HR
主要问了一下意向 看到钱那么少我也没什么兴趣，直言钱太少，意向不大
估计不会发offer了</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E5%A4%B4%E6%9D%A1%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E5%A4%B4%E6%9D%A1%E4%B8%80%E9%9D%A2/</guid>
      <description>static 的sync 和 实例的sync 垃圾回收器 内存碎片 二叉树的转链表 JVM 排查命令 JVM OOM 有哪几种情况 juc 下面的栅栏 这些类有了解过吗？ Java 内存模型 线程池参数 主要作用 我爱小a redis 数据结构 有限状态机 CAS 是什么 ABA 问题 分布式锁的实现 JVM 内存模型 数据库索引的实现 叶子节点内部节点的区别 rabbitMQ 怎么用吗 java 的垃圾回收机制 HashMap 为什么线程不安全 场景 hashcode 怎么用 equal重写  对于一个指定位置的水坑，他所能承载的水的垂直数目取决于左右两边最高中的较小的那一块，所以通过遍历，就可以得出。
class Solution { public int trap(int[] height) { int sum = 0; int left = 0; int right = height.length-1; int left_max =0; int right_max = 0; while(left&amp;lt;right){ if(height[left]&amp;lt;height[right]){ if(height[left]&amp;gt;left_max){ left_max = height[left]; } else{ sum += left_max-height[left]; } left++; } else{ if(height[right]&amp;gt;right_max){ right_max = height[right]; } else{ sum += right_max-height[right]; } right--; } } return sum; } } 用双指针来做，对于一个数组，我们分别定义left，right 如果height[left]&amp;gt;height[right] 说明right决定了这个位置水的容量 如果大于最大的就跟新小于就sum++</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E5%A4%B4%E6%9D%A1%E4%BA%8C%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E5%A4%B4%E6%9D%A1%E4%BA%8C%E9%9D%A2/</guid>
      <description>在爱奇艺做了什么？ 排障
负载均衡算法 怎么 把流量打均匀 session（redis）
一个对象的生命周期
JVM 是怎么创建一个线程的
 两台机子最多能建立多少个TCP链接  主机{ip，port} - 客户端{ip，port}
ipv4的长度是32位，得2^32，端口16位，得2^16，共计2^48。同时还要受限与最大文件描述符数目及内存限制
  为什么要有三次握手和四次挥手
  三次握手怎么匹配 sq number
  布隆过滤器怎么调参
布隆过滤器的哈希函数是自己实现的吗? 不是
为什么wait time 是2MSL 如果是10MSL 20MSL 会怎么样
MSL 是怎么算出来的？
NIO 的核心理念是什么？为什么叫NIO
NIO 多路复用select() epoll() 演进流程 同步到异步
原子类线程调度的关系
JVM 内存模型（你给我说清楚 是JVM 还是JMM)
  一定要有老年代和新生代吗 没有没关系吗？
这个主要看JVM 规范
  JMM 工作内存 和 主内存主要是什么
栈数据区 操作数
  JMM 最重要的准则是什么 happens before ？</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E6%94%AF%E4%BB%98%E5%AE%9D%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E6%94%AF%E4%BB%98%E5%AE%9D%E4%B8%80%E9%9D%A2/</guid>
      <description>对象存在的周期
java的垃圾回收器 几个
爬虫项目怎么监控价格
redis单点还是集群化 单点可靠性
fork 是 new 一个子进程
redis 在超出内存的情况下怎样进行IO操作
如何学习的 是学习java 还是python
 Java 实现切面变成 和 依赖注入 为什么c/C++不能这样做（扯到了编程范式 java的包访问机制） 通过反射实例化对象，存入到Spring的bean容器中  实例方法和静态方法不一样（感觉打得不够深入）
静态方法怎么用（我把单例模式全答了voliate 饿汉懒汉 枚举）
常见的异常类 （runtimeEx null classnot 索引溢出）
classnotfound 情况 哪几种 （类加载器，环境变量没配（扯淡呢 环境变量没配根本找不到java））
 spring 事物传播机制 （woc 这是什么） 外围方法未开启事务的情况下Propagation.REQUIRED修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。 Propagation.REQUIRED修饰的内部方法会加入到外围方法的事务中，所有Propagation.REQUIRED修饰的内部方法和外围方法均属于同一事务，只要一个方法回滚，整个事务均回滚。 Propagation.REQUIRES_NEW修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。 Propagation.REQUIRES_NEW修饰的内部方法依然会单独开启独立事务，且与外部方法事务也独立，内部方法之间、内部方法和外部方法事务均相互独立，互不干扰。  ThreadLocal 有啥作用（感觉答得不够深）
session和cookie区别 session 怎么多服务器统一（答了redis）
 前端安全 XSS？？  XSS 攻击 通过html 注入 插入恶意脚本，前端没有经过检验就操作 使用正则通过标签替换进行解码 CSRF 攻击 登录网站种下cookie 不小心访问了恶意网站， 你的cookie被恶意网站捕获 请求地址中添加token。    etc/hosts 有啥用</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E6%94%AF%E4%BB%98%E5%AE%9D%E9%A3%8E%E6%8E%A7%E9%83%A8%E9%97%A8%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E6%94%AF%E4%BB%98%E5%AE%9D%E9%A3%8E%E6%8E%A7%E9%83%A8%E9%97%A8%E4%B8%80%E9%9D%A2/</guid>
      <description>遇到的反爬虫
 robot.txt user-agent cookie加密 ip 封禁    验证码怎么破解
  知道CNN技术吗
 答了 卷积神经网络    布隆过滤器误判率 在redis的书上有
  为什么会上布隆过滤器
  mysql 查询优化是怎么优化的
 用between and 如果用 * 就可以走主键索引 但是使用limit 去 * 不符合最左前缀 就会导致不走索引 全量查询    用了ORM吗 用什么连接驱动
 用了mysqldb 没有pymysql    DB里面的事务 讲了事务隔离机制
  将一下未提交读
  讲一下串行读 面试官讲了秒杀场景 可以适用
  爬虫的DFS 有遇到循环的问题吗
  为什么没有用BFS 用的DFS</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E6%9C%89%E8%B5%9E%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E6%9C%89%E8%B5%9E%E4%B8%80%E9%9D%A2/</guid>
      <description>负载均衡算法维持会话使用的算法 7层 nio 中 在 unix 函数用了什么？ epoll ？ cas 自旋的好处？ 线程池如何运作？他的参数是什么？阻塞队列的作用是什么？为什么要有阻塞队列 nio 多路复用是同步还是异步的? mysql 悲观锁乐观锁 用sql 怎么写 线程池在请求来了的时候是怎么创建线程和利用请求队列的？ mysql 事务是怎么实现的? HashMap 线程不安全的情况? 1.8 1.7 分析 聚集索引与非聚集索引的区别 mysql 默认的隔离级别 volatile 的实现 内存屏障的实现 指令重排序的应用场景 mysql 的两个引擎的区别 性能 差多少 为什么？ chm 怎么计算分段的数量 构造函数里面有 忘了 项目中有没有用到过行锁，怎么实现的（四种锁）？ 死锁发生的条件，对锁超时，如果遇到抢占锁怎么办？  LVS 持久性连接 从用户端来解释，就是当一个用户第一次访问被负载均衡代理到后端服务器A并登录后，服务器A上保留了用户的登录信息；当用户再次发送请求时，根据负载均衡策略可能被代理到后端不同的服务器，例如服务器B，由于这台服务器B没有用户的登录信息，所以导致用户需要重新登录。这对用户来说是不可忍受的。所以，在实施负载均衡的时候，我们必须考虑Session的问题。
问题出在哪里？ 如何处理？  会话保持（案例：Nginx、Haproxy） 会话复制（案例：Tomcat） 会话共享（案例：Memcached、Redis）  我们这里主要讲的是 会话保持的方式，这个方式也主要是从负载均衡这一层进行解决。
首先讲两个十分通用的方式吧！
会话保持 IP_HASH 每个请求按照访问的ip的Hash结果进行分配，这样每个访客可以访问同一个后端服务器，达到保持Session的方法。
upstream bakend { ip_hash; server192.168.0.11:80; server192.168.0.12:80; } Cookie 识别 也就是Haproxy在用户第一次访问的后在用户浏览器插入了一个Cookie，用户下一次访问的时候浏览器就会带上这个Cookie给Haproxy，Haproxy进行识别</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E8%85%BE%E8%AE%AF%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E8%85%BE%E8%AE%AF%E4%B8%80%E9%9D%A2/</guid>
      <description>  抽象类和接口有什么区别
  在接口里面怎么去实现一个数据的共享
  有用过注解嘛 （我这里简单的回答了一下，应该要扯到编译时和运行时 和元编程
  spring boot 如何自动配置
  Java 如何去创建一个JDBC连接
  判断变量，两个变量相等 == 和 equal的区别
  HashMap 的工作原理 应该讲一下扩容机制的
  打开腾讯的首页，从你输入网址到时候呈现出来，整个过程会经过哪些环节。
  HTTPS 非对称加密
  长连接和短连接的区别
  什么时候用长连接 什么时候用短链接
  tcp怎么进行流量控制
  linux 命令怎么去抓包一个端口
  用文件A 去替换一个目录下不同层次的文件B
  排序的几种方式 以及他们的区别
  希尔排序 快排 是如何排序的 时间复杂度 思路
  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E8%85%BE%E8%AE%AF%E4%BA%8C%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E8%85%BE%E8%AE%AF%E4%BA%8C%E9%9D%A2/</guid>
      <description>JVM 排查命令
JVM OOM 有哪几种情况
juc 下面的栅栏 这些类有了解过吗？
Java 内存模型
线程池参数 主要作用 我爱小a
redis 数据结构
有限状态机
CAS 是什么 ABA 问题
分布式锁的实现
数据库索引的实现 叶子节点内部节点的区别
最左匹配对于ABC 如果A 相同 比较B 如果B相同比较C
rabbitMQ 怎么用吗
java 的垃圾回收机制
HashMap 为什么线程不安全 场景
hashcode 怎么用 equal重写
 自反性：对于任意的引用值x，x.equals(x)一定为true。  对称性：对于任意的引用值x 和 y，当x.equals(y)返回true时， y.equals(x)也一定返回true。  传递性：对于任意的引用值x、y和ｚ，如果x.equals(y)返回true， 并且y.equals(z)也返回true，那么x.equals(z)也一定返回true。  一致性：对于任意的引用值x 和 y，如果用于equals比较的对象信息没有被修 改，多次调用x.equals(y)要么一致地返回true，要么一致地返回false。  非空性：对于任意的非空引用值x，x.equals(null)一定返回false。   OOM 怎么排查
 看堆栈  方法区 运行时常量池溢出
如果是 PermGen space 就代表属于方法区
 直接内存溢出  Jmap 没有明确的信息</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E8%98%91%E8%8F%87%E8%A1%97%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E8%98%91%E8%8F%87%E8%A1%97%E4%B8%80%E9%9D%A2/</guid>
      <description>负载均衡 DR
HashMap
GC
ping 6w 台虚机怎么做
TCP 定时器
拥塞控制
管道种类</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8D%E7%BD%91%E5%95%86%E9%93%B6%E8%A1%8C%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8D%E7%BD%91%E5%95%86%E9%93%B6%E8%A1%8C%E4%B8%80%E9%9D%A2/</guid>
      <description>1500w数据怎么用redis去重 （答了布隆过滤器）
  AB两个索引 是复合索引 where B=&amp;rdquo;?&amp;rdquo; 会走复合索引吗？
 利用索引中的附加列可以减少搜索的范围，但使用一个具有两列的索引 不同于使用两个单独的索引。如果您知道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不姓，电话簿将没有用处。 在创建复合索引的时候，应该仔细考虑列的顺序。索引中的所有列执行搜索，或者针对前几条的搜索可以使用复合索引。 最左前缀原则是最左优先，以最左边的为起点任何连续的索引都能匹配上    1500w 怎么确定between and 范围
  怎么优化1500w数据中一个区间的数据的查询（我答了limit 1）
  有限状态机的概念
  有限状态机在某个状态出现问题 怎么处理 怎么返回原来的状态
  事务中出现了长时间操作该如何处理
  事务的隔离级别（我答了事务传播。。。。。）
 READ UNCOMMITTED（未提交读） 事务的修改即使没有提交对其他事务都是可见的，事务可以读取未提交的数据也就被称为脏读（Dirty Read） 一般很少使用。 READ COMMITED（提交读） 一个事务开始的时候只能“看见”已经提交事务所做的修改，也就是说一个事务从开始到提交之前，所做的任何修改 都是对其他事务不可见的。 REPEATABLE READ（可重复读） MySQL 的默认事务隔离级别 无法解决环行（Phantom Row） SERIALIZABLE（可串行化）    开启事务的时候update一个数据 被另一个数据操作了怎么处理
  mysql 的锁 了解过吗？
  线程池了解吗</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8D%E7%BD%91%E5%95%86%E9%93%B6%E8%A1%8C%E4%BA%8C%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8D%E7%BD%91%E5%95%86%E9%93%B6%E8%A1%8C%E4%BA%8C%E9%9D%A2/</guid>
      <description>Java的内存回收机制
用户态和内核态
喜欢linux的哪一点
linux的内存管理是怎么做的
Java的面向对象思想
用java写过那些项目？</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/linux/docker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/linux/docker/</guid>
      <description>1、编写Scrapy的配置文件 [scrapyd] eggs_dir = eggs logs_dir = logs items_dir = jobs_to_keep = 5 dbs_dir = dbs max_proc = 0 max_proc_per_cpu = 10 finished_to_keep = 100 poll_interval = 5.0 bind_address = 0.0.0.0 http_port = 6800 debug = off runner = scrapyd.runner application = scrapyd.app.application launcher = scrapyd.launcher.Launcher webroot = scrapyd.website.Root [services] schedule.json = scrapyd.webservice.Schedule cancel.json = scrapyd.webservice.Cancel addversion.json = scrapyd.webservice.AddVersion listprojects.json = scrapyd.webservice.ListProjects listversions.json = scrapyd.webservice.ListVersions listspiders.json = scrapyd.webservice.ListSpiders delproject.json = scrapyd.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/linux/git/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/linux/git/</guid>
      <description>创建本地分支推到服务器 创建新的本地分支 git checkout -b dd 
从远程拉取分支 git checkout -b dd remote/origin/dd
创建远程分支 git push origin dd:dd
切换远程服务地址 删除远程服务器地址 git remote rm origin
添加新的 git remote add origin https://github.com/xiantang/jdcrawler
添加多个远程源 查看远程源 git remote -v
origin ssh://a.git (fetch) origin ssh://a.git (push) 添加一个名为 us 远程源
git remote add us ssh://c.git
查看远程源 git remote -v
origin ssh://a.git (fetch) origin ssh://a.git (push) us ssh://b.git (fetch) us ssh://b.git (push) 获取所有远程分支到本地 git fetch --all
复原submodule</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/linux/%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/linux/%E5%91%BD%E4%BB%A4/</guid>
      <description>ngrok 内网映射 ./ngrok authtoken 5ioHp3Qr1ztsMz9adXTH7_5GF6YTpEnczVrjGvmyd6R
./ngrok http 80
重启nginx ps -ef | grep nginx 
从容停止 kill -QUIT 主进程号 快速停止 kill -TERM 主进程号 强制停止 kill -9 nginx
关闭nginx 开机自动启动 systemctl disable nginx.service
重启redis
etc/init.d/redis-server restart
验证密码
auth 123456zjd
 OK
 远程连接
redis-cli -h 111.231.255.225 -p 6379
scrapy-redis 设置密码
REDIS_URL = &amp;#39;redis://:{psw}@{host}:{port}&amp;#39;.format( host=&amp;#39;111.231.255.225&amp;#39;, # your server ip port=&amp;#39;6379&amp;#39;, psw=&amp;#39;123456zjd&amp;#39;, ) 查找指定进程  ps -ef | grep mmp-front //mmp-front是进程关键字
VNC 关闭指定屏幕</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/middware%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/middware%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/</guid>
      <description>kafka 基础知识
 Topic：特指Kafka处理的消息源的不同分类，其实也可以理解为对不同消息源的区分的一个标识； Partition：Topic物理上的分组，一个topic可以设置为多个partition，每个partition都是一个有序的队列，partition中的每条消息都会被分配一个有序的id（offset）； Message：消息，是通信的基本单位，每个producer可以向一个topic（主题）发送一些消息； Producers：消息和数据生产者，向Kafka的一个topic发送消息的过程叫做producers（producer可以选择向topic哪一个partition发送数据）。 Consumers：消息和数据消费者，接收topics并处理其发布的消息的过程叫做consumer，同一个topic的数据可以被多个consumer接收； Broker：缓存代理，Kafka集群中的一台或多台服务器统称为broker。  在调用conusmer API时，一般都会指定一个consumer group，该group订阅的topic的每一条消息都发送到这个group的某一台机器上。借用官网一张图来详细介绍一下这种情况，假如kafka集群有两台broker，集群上有一个topic，它有4个partition，partition 0和1在broker1上，partition 2和3在broker2上，这时有两个consumer group同时订阅这个topic，其中一个group有2个consumer，另一个consumer有4个consumer，则它们的订阅消息情况如下图所示：
consumerGroup
因为group A只有两个consumer，所以一个consumer会消费两个partition；而group B有4个consumer，一个consumer会去消费一个partition。这里要注意的是，kafka可以保证一个partition内的数据是有序的，所以group B中的consumer收到的数据是可以保证有序的，但是Group A中的consumer就无法保证了。
group读取topic，partition分配机制是：
 如果group中的consumer数小于topic中的partition数，那么group中的consumer就会消费多个partition； 如果group中的consumer数等于topic中的partition数，那么group中的一个consumer就会消费topic中的一个partition； 如果group中的consumer数大于topic中的partition数，那么group中就会有一部分的consumer处于空闲状态。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/middware%E4%B8%AD%E9%97%B4%E4%BB%B6/limiterrater/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/middware%E4%B8%AD%E9%97%B4%E4%BB%B6/limiterrater/</guid>
      <description>QS 接口调用频率限制
背景
分析了一下之前 890 的事故，结合之前的代码逻辑聊一下吧.
因为我们服务端调用代码的逻辑为异步，所以在请求的过程中是没有阻塞的。
def usersList(projectId: Int, ai: String, groupId: String, field: String, attrList: Seq[String], start: Int, end: Int): Future[Seq[UserInfo]] = { var index = start val requests = new ArrayBuffer[GroupUsersRequest]() // todo: 一个登陆用户对应多个设备的情况下 total 小于实际设备数  while (index &amp;lt; end) { val request = GroupUsersRequest( ....... ) } // 同时向qs请求  Future.traverse(requests.toList) { request =&amp;gt; requestInsight(request) }.map(_.flatten) } 18 w 个用户数据 会被切分成为 180 个 1000为单位的查询请求，由于没有阻塞 所以每台机器会瞬间发送 45 个请求到qs，也就是几毫秒发 180 连接到 QS，最终这些请求会变成查询压力打到数据库，将数据打挂。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/middware%E4%B8%AD%E9%97%B4%E4%BB%B6/rabbitmq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/middware%E4%B8%AD%E9%97%B4%E4%BB%B6/rabbitmq/</guid>
      <description>rabbitmq-server用来启动RabbitMQ服务器进程：
 # rabbitmq-server -detached
 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/network%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/internet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/network%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/internet/</guid>
      <description>计算机网络 网络分层  应用层:网络进程到应用程序。针对也定的应用规定各层协议。端系统用软件实现。 表示层:负责数据的加密解密，把数据转换成独立于机器的数据。 会话层:主机间通讯，管理应用程序之间的会话。 传输层:在网络的各个节点之前可靠的分发数据包。 网络层:进行地址分配和路由。 数据链路层:可靠的点对点数据直链。 物理层:不一定可靠的点对点数据直链。  底层网络协议 ARP 基本功能为透过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。在每台安装有TCP/IP协议的电脑或路由器里都有一个ARP缓存表，表里的IP地址与MAC地址是一对应的。
NAT 基本功能为透过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。在每台安装有TCP/IP协议的电脑或路由器里都有一个ARP缓存表，表里的IP地址与MAC地址是一对应的。
HTTP 协议  构建在TCP/IP协议之上 默认端口号80 无连接无状态  状态码含义  1** 服务器收到请求，需要请求者继续执行操作。 2** 成功,操作被成功接收并处理。 3** 重定向，需要进一步的操作以完成请求。  301 Moved Permanently。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302 Moved Temporarily。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 304 Not Modified。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源。   4**	客户端错误，请求包含语法错误或无法完成请求  400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。 401 Unauthorized 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因 404 Not Found 请求的资源不存在，例如，输入了错误的UR   5**	服务器错误，服务器在处理请求的过程中发生了错误  500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。 503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。    GET 和 POST 的区别 GET可提交的数据量受到URL长度的限制，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。 理论上讲，POST是没有大小限制的，HTTP协议规范也没有进行大小限制，出于安全考虑，服务器软件在实现时会做一定限制。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/network%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/network%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA%E7%AC%94%E8%AE%B0/</guid>
      <description>网络概论笔记 传输层 TCP:客户端与服务器端需要维持会话，TCP需要传输的文件进行分段 传输进行可靠传输
流量控制功能
UDP: 一个数据包就能够完成数据传输，不需要建立绘画，不需要流量控制
etc：DNS
屏幕 广播 （多播）
传输层协议和应用层协议的关系
HTTP =TCP + 80
HTTPS = TCP+443
RDP = TCP+3389
FTP = TCP + 31
telnet = TCP + 23
SQL = TCP+1433
DNS = UDP + 53
POP3 = TCP +110
IP 层协议主要提供了主机之间的逻辑通讯
TCP/UDP 主要提供了应用程序之间的逻辑通讯
传输层的端口：TCP 6 UDP 17 ICMP 17
登记端口号：数值1024~49151
客户端端口号：数值49152~6553
UDP 需要从 网络层提炼出20个字节 一起计算首部
伪首部 源地址
目标地址
源地址+目标地址 总和为8个字节
全 0 和 UDP 协议号以及 UDP 的长度</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/os%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/assembly/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/os%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/assembly/</guid>
      <description>基础知识 汇编语言的组成  汇编指令 伪指令 其他符号  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/os%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/udacity-os/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/os%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/udacity-os/</guid>
      <description>Concept OS Elements  Abstractions  process thread file socket memory page   Mechanisms  create schedule open write allocate(分配)   Policies(策略)  least-recently used(LRU) earliest deadline first (EDF)    关于Mechanisms 和 Polices的区别我其实迷惑了很久。
其实总结出来很简单Mechanisms 机制 指的是 what to do
Polices 指的是 how to do
也可以这样理解机制是策略的更高一层抽象，策略是指具体如何实现的方式，机制则是我需要这个功能，但是不关注实现。
举个例子就是Linux内核的调度器（scheduler），提供了任务调度需要的原语操作和结构，并且实现了多种调度算法。
Process what is a Process : state of a program when executing loaded in memory. (active entity)
 instance of an executing program Synonymous with &amp;ldquo;task&amp;rdquo; or &amp;ldquo;job&amp;rdquo;  A process is like an order of toys</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/posts/k/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/posts/k/</guid>
      <description>kubectl -n k8s-marketing-automation exec -ti k8s-marketing-automation-opm-687d45b94d-4vvt6 bash &amp;ndash;kubeconfig=/Users/xiantang/project-conf/k8s-config
kubectl -n k8s-marketing-automation get pods &amp;ndash;kubeconfig=/Users/xiantang/project-conf/k8s-config
{ //纬度 &amp;#34;dimensions&amp;#34;: [ &amp;#34;tm&amp;#34; ], // 粒度 &amp;#34;granularities&amp;#34;: [ { &amp;#34;id&amp;#34;: &amp;#34;tm&amp;#34;, &amp;#34;interval&amp;#34;: 3600000, &amp;#34;period&amp;#34;: &amp;#34;abs:1573488000000,1573574399999&amp;#34; } ], // 指标 &amp;#34;metrics&amp;#34;: [ { &amp;#34;id&amp;#34;: &amp;#34;uc&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;prepared&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;用户量&amp;#34; } ], &amp;#34;targetUser&amp;#34;: &amp;#34;uv&amp;#34;, //时间 &amp;#34;timeRange&amp;#34;: &amp;#34;day:2,1&amp;#34;, // 是否只进行聚合计算 &amp;#34;aggregation&amp;#34;: true, // 聚合函数 &amp;#34;aggregator&amp;#34;: &amp;#34;sum&amp;#34; } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/python/scrapy-api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/python/scrapy-api/</guid>
      <description>开启scrapyd的服务 scrapyd
查看项目中的scrapy scrapy list</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/python/%E5%AE%89%E8%A3%85python3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/python/%E5%AE%89%E8%A3%85python3/</guid>
      <description>创建文件 mkdir /usr/local/python3
下载源码 wget https://www.python.org/ftp/python/3.6.3/Python-3.6.3.tgz
解压 tar -xvf Python-3.6.3.tgz
cd Python-3.6.3/
稍微解释上面这句命令，这句话的大致目的就是把python的安装目录指定一下，这样的话，里面的一些bin目录、lib目录就都会存放在这个目录下面。
./configure --prefix=/usr/local/python3Dir
如果报错就表示gcc组件没有安装
yum install -y gcc
编译源码
make
执行安装
make install
出现错误 zipimport.ZipImportError: can&#39;t decompress data; zlib not available make: *** [install] 错误 1
安装zlib相关的依赖包
yum -y install zlib*</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/python/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/python/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</guid>
      <description>激活虚拟环境。
source venv/bin/activate
开启python项目 sudo python3 manage.py runserver 0.0.0.0:80
后台运行任务
暂停 ctrl+z
将程序在后台运行 bg %1
取消控制 disown
退出虚拟环境 deactivate</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/scala/akka-%E6%BA%90%E7%A0%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/scala/akka-%E6%BA%90%E7%A0%81/</guid>
      <description>object Main1 extends App { val system = ActorSystem(&amp;#34;HelloSystem&amp;#34;) val jazzListener = system.actorOf(Props[Listener]) val musicListener = system.actorOf(Props[Listener]) system.eventStream.subscribe(jazzListener, classOf[Jazz]) // jazzListener 订阅 Jazz 事件  system.eventStream.subscribe(musicListener, classOf[AllKindsOfMusic]) // musicListener 订阅 AllKindsOfMusic 以及它的子类 事件  // 只有 musicListener 接收到这个事件  system.eventStream.publish(Electronic(&amp;#34;Parov Stelar&amp;#34;)) // jazzListener 和 musicListener 都会收到这个事件  system.eventStream.publish(Jazz(&amp;#34;Sonny Rollins&amp;#34;)) } subscribe 逻辑 同步地将 subcriber 和 to 加入到 subscriptions 中，diff 应该是和之前的一次比较保证不会重复发送?
def subscribe(subscriber: Subscriber, to: Classifier): Boolean = subscriptions.synchronized { val diff = subscriptions.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/scala/learn-scala/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/scala/learn-scala/</guid>
      <description>声明隐式转换
这里的问题是 2*r 等价于 2. 叫 r)，因此这是一个对 2 这个整数的方法调 用。 但Int类并没有一个接收Rational参数的乘法方法一一它没法有这样一 个方法，因为 Rational 类并不是 Scala类库中的标准类
不过， Scala有另外一种方式来解决这个问题 :可以创建一个隐式转换( implicit conversion )，在需要时自动将整数转换成有理数 。 可以往解释器里添加行:
implicit def inToRational(x :Int) = new Rational(x) val r = new Rational(2,3) println(2*r) 生成器
def scalaFiles = for { file &amp;lt;- fileHere if file.getName.endsWith(&amp;#34;.sh&amp;#34;) } yield file scalaFiles 每次迭代生成一个可以被记住的值
函数和闭包 局部函数 既然现在 processLine 定义在 processFile 内部，我们还可以做另一项 改进 。 注意到 filename 和 width 被直接透传给助手函数，完全没有变吗?这 里的传递不是必须的，因为局部函数可以访问包含它们的函数的参数 。 可以直 接使用外部的 processFile 函数的参数.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/scala/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/scala/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>Sbt.
常用命令[ ](https://www.scala-sbt.org/1.x/docs/zh-cn/Running.html#常用命令) 下面是一些非常常用的的 sbt 命令。更加详细的列表请参见 命令行参考。
   clean 删除所有生成的文件 （在 target 目录下）。     compile 编译源文件（在 src/main/scala 和 src/main/java 目录下）。   test 编译和运行所有测试。   console 进入到一个包含所有编译的文件和所有依赖的 classpath 的 Scala 解析器。输入 :quit， Ctrl+D （Unix），或者 Ctrl+Z （Windows） 返回到 sbt。   run &amp;lt;参数&amp;gt;* 在和 sbt 所处的同一个虚拟机上执行项目的 main class。   package 将 src/main/resources 下的文件和 src/main/scala 以及 src/main/java 中编译出来的 class 文件打包成一个 jar 文件。   help &amp;lt;命令&amp;gt; 显示指定的命令的详细帮助信息。如果没有指定命令，会显示所有命令的简介。   reload 重新加载构建定义（build.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/todo/need-to-learn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/todo/need-to-learn/</guid>
      <description> kafka 保证幂等性 微服务到底是什么 Google protobuf  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/tomcat/io%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/tomcat/io%E6%A8%A1%E5%9E%8B/</guid>
      <description>单线程阻塞模型 特点
 单线程:服务端只有一个线程处理客户端的所有请求 阻塞I/O 在读写线程的时候是阻塞的，读取客户端数据要等待客户端发送数据并且把操作系统内核的数据复制到用户进程才能解决阻塞。  缺点
 性能很差，只有一个线程处理数据，当前线程正在处理请求的时候，无法处理其他请求。  多线程阻塞模型 利用多线程机制多分配一个线程，当多个请求过来的时候，服务器端在接受客户端请求后，分别创建多个线程对他们进行处理。客户端与服务器线程的比例是1:1
特点
 能够提高服务器端的并发处理能力，但是每个线程需要分配一个线程池进行操作。 多线程需要上下文切换。  单线程非阻塞 I/O 模型 单线程非阻塞I/O模型的最大特点是，在调用读取和写入接口后立马返回，而不是阻塞。
探讨单线程非阻塞I/O 模型先了解一下非阻塞情况下的套字节检测机制。
 应用程序遍历套字节时间检测,尝试读写。使用一个线程负责遍历套字节列表，同时处理数据的拼凑。 内核遍历套字节检测:  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/tomcat/tomcat-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-1-httprequestresponse/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/tomcat/tomcat-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-1-httprequestresponse/</guid>
      <description>接收器 阀
Tomcat 自带线程池
HTTP Web 服务器也称为超文本传输协议服务器，因为他使用HTTP 与其客户端进行通讯。
HTTP 是应用层协议，由响应和请求组成，是一个标准的B/S 模型,同时也是一个无状态的协议，在同一个客户端中，此次请求和上次请求没有对应关系。
HTTP 允许Web服务器和浏览器通过Internet 发送请求，他是一种基于“请求－响应”的协议。客户端请求一个文件，服务端对于该请求进行响应。
HTTP 请求 一个HTTP 请求包括三部分:
 请求方法－－－统一资源标识符 URI 协议／版本 请求头 实体  POST /ajax/ShowCaptcha HTTP/1.1\r\n Content-Type: application/x-www-form-urlencoded\r\n Host: www.renren.com\r\n Content-Length: 36\r\n \r\n email=%E5%B7%A5&amp;amp;password=asdasdsadas 请求方法 －－ URI －－ 协议／版本
POST /ajax/ShowCaptcha HTTP/1.1\r\n
会出现在第一行
每个请求头之前都会用回车／换行符隔开 (CRLF)
并且请求头和请求实体之间会有一个空行，空行只有 CRLF 符号。CRLF告诉HTTP服务器请求的正文从哪里开始。
HTTP 响应 与HTTP 请求相似，HTTP 响应也分三部分:
 协议－－ 状态码 响应头 响应实体段  HTTP/1.1 200 OK\r\n Date: Sat, 31 Dec 2005 23:59:59 GMT\r\n Content-Type: text/html;charset=ISO-8859-1\r\n Content-Length: 122\r\n \r\n &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Wrox Homepage&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/tomcat/tomcat-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-2-%E8%BF%9E%E6%8E%A5%E5%99%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/tomcat/tomcat-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-2-%E8%BF%9E%E6%8E%A5%E5%99%A8/</guid>
      <description>在解释Tomcat 的NIO 连接器之前我们可以来聊一个Tomcat 的StringManage 类
StringManage StringManage 其实是Tomcat用来处理消息的公用类。
其实思路就是每个包名对应一个Stringmanager对象，而非所有公用一个Stringmanager对象！
Tomcat为每一个包提供一个StringManager实例，相当于一个包一个单例的效果
我们来康康这个一个包一个单例是如何实现的呢？
/** * Get the StringManager for a particular package and Locale. If a manager * for a package/Locale combination already exists, it will be reused, else * a new StringManager will be created and returned. * * @param packageName The package name * @param locale The Locale */ public static final synchronized StringManager getManager( String packageName, Locale locale) { Map&amp;lt;Locale,StringManager&amp;gt; map = managers.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/tomcat/tomcat-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-3-%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/tomcat/tomcat-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-3-%E5%AE%B9%E5%99%A8/</guid>
      <description>容器 servlet 容器是用来处理servlet 资源，为Web 客户端填充 response 的模块
Tomcat 有4种容器:
 Engine 整个 Catalina servelt 引擎 Host 包含了一个或者多个Context 容器的虚拟主机 Context 表示一个web app 一个context 有多个Wrapper Wrapper 表示一个独立的servelt  这些容器都实现了Container 接口
我们的本章的上半部分主要讲解的是Wrapper 与 Context
Container 因为所有的容器都实现于Tomcat 的Container 接口所以我们讲解一下Container 接口
Container 主要需要实现的方法是 addChild() 和 removeChild()
/** * Add a new child Container to those associated with this Container, * if supported. Prior to adding this Container to the set of children, * the child&amp;#39;s &amp;lt;code&amp;gt;setParent()&amp;lt;/code&amp;gt; method must be called, with this * Container as an argument.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/tomcat/tomcat-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-4-%E8%BD%BD%E5%85%A5%E5%99%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/tomcat/tomcat-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-4-%E8%BD%BD%E5%85%A5%E5%99%A8/</guid>
      <description>类加载器 类加载的好处是可以将Java 类动态的加载到 JVM 中并且运行，就可以在程序运行中再加载类。
在Java 体系中，我们可以将系统分为3中类加载器:
 启动类加载器: 加载Java 的核心库，把核心的Java 类加载进JVM。这个加载器使用的原生 C++ 实现，是所有其他类加载器的父类加载器，负责加载&amp;lt;Java_HOME&amp;gt;/jre/lib 目录下的JVM 指定类库。 拓展类加载器:加载Java 的拓展类库，加载&amp;lt;Java_HOME&amp;gt;/jre/lib/etx 目录中的类。 应用程序类加载器: 系统类加载器负责加载用户类库中的指定类库。  并且类加载器还有各种机制:
  在Java 中，我们用完全匹配类命名来标识一个类，就是用包名.类名，但是在JVM 中一个类由完全匹配类名和一个类加载器实例的ID来标识一个类，当我们判断两个类是否相等的时候，只要他们由两个不同的类加载器加载的前提下才有意义，否则就算相同的字节码，如果由不同的类加载器实例加载，这两个类也是不相同的。这种特征为我们提供了隔离机制。
  类加载器有一个全盘机制当类加载加载一个类的时候，他的依赖的应用的其他所有类都由这个类加载器加载，除非显示的调用这个其他类加载加载。
  对于类加载器加载对象的时候他只会去加载那些必须的对象，只会加载父类对象，理由也很简单为了实现多态，需要将父类的入口方法连接起来，实现方法表。对于这些父类，调用加载子类的类加载器去加载，并且通过向上委托的方式加载。
  只有真正执行到对应的代码，遇到 new 关键词的时候，才会去加载对应的外部引用的类，达到了按需处理的效果。
  如果当前类加载器，已经加载了对应的类，第二次遇到new时候，Java 会隐式的从方法区中获取对应的类。
    载入器 Tomcat 如果使用的系统的类加载器去加载某个servlet 中所有需要使用的类，那么servlet 就可以访问所有的类，比如 Java 虚拟机中环境变量中CLASSPATH 指明路径下的所有类和库。servlet 应该只允许再入WEB-INF/class 中的目录，以及它的子目录下的类。
并且Tomcat 需要实现自定义类加载器的原因是因为为了提供自动重载的功能。类载入器会开启一个线程不断检查文件的时间戳。如果要实现重载入的功能就必须实现Reload 接口。在Tomcat 7 中已经将Reloader 接口合并入Loader 接口中。
​
WebAppLoader 对于Tomcat 的重载，如果你在 conf/server.xml 的 ｀｀标签设置了 reloadable 为ture 的话,Tomcat 会为你开启一个后台线程，去监控该 Context 中所有classes 文件的修改，并且重新加载。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/tomcat/%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2-%E6%89%8B%E5%86%99java-http-server/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/tomcat/%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2-%E6%89%8B%E5%86%99java-http-server/</guid>
      <description>这坑开了有三个多月了，是今年春招的时候开始写的方轮子。感觉很多基本的功能都已经完成了，下面分享上来给大家讲下写这个方轮子的心路历程。
起因 起初在牛客上看到一篇帖子 《震惊！文科生如何三个月转行成为Java工程师？ 》 这个作者自己写了一个HTTP server ,我突然想到为什么我不去实现一个呢？
因为其实在转到 Java（为了就业） 之前我是学习Python的，曾经用Python 实现过一个类似于 Scrapy 的爬虫框架，但是因为转到Java之后迫于繁杂的 Java 知识体系，也就没有想到写轮子这件事。但是这篇博客真的激起了我写轮子的欲望。
如何做？怎么做？ 但是如何从头写一个服务器呢?就是模仿！
我看到那篇帖子的作者曾经提到他是看了一个Java SE的学习视频跟着慢慢写了一个1000多行的服务器，再自己慢慢迭代代码。
行！就这样，去找这个视频！但是发现 作者留下了一个失效百度云地址。不过这怎么能阻挡我写轮子的欲望，经过一下午的谷歌，终于找到了这个视频 2018百战程序员JAVA全系列终结版第11阶：手写服务器httpserver项目。
是一个培训班的视频，起初我有些抵触，因为我觉得对我来说看培训班的视频的学习效率会不怎么高，没想到这个作者讲的十分的好，带我重新理解了一遍，web.xml 解析，反射解耦这些操作。花了两天的时间跟着视频做了一个十分简易的 BIO HTTP server。
看作者源码 一个简易的BIO server 并不使我满足，于是我开始去 Github 上学习作者的源码 WebServer 。当时还对 NIO 没有一个明确的概念，对于 reactor 模型没有一个深刻的概念，不过没有什么能阻挡我的，查阅了资料并且了解了 unix IO 模型之后的我就开始继续看着作者的源码写轮子。
期间主要实现了:
NIO Reactor 我的实现是用一个 Acceptor 阻塞的获取Socket 连接，然后使用多个Poller 非阻塞轮询 socket 读事件，然后交给线程池处理。
其实对于线程池数目与Poller 的调参也有需要注意的点，我这边因为Poller的操作是计算密集型的操作所以选择了 CPU 核心数目+1 的方案，而后面的线程池我则使用的是200个线程(IO 密集型)，而且需要注意的一点是对于溢出调度队列的线程，系统默认是采用抛出异常的方式，我这边采用的是 调用者执行的方式 使用主线程去串行的执行溢出的任务。这样的好处是会慢，但是也不会出现抛出异常的情况。
协同开发 这段时间，因为最最基础的功能已经开发完毕，所以我把我的轮子分享给牛客上认识的春招战友们一起开发。
我最要感谢的是和我一起开发的时候，一直交流的伙伴鸡哥，那段时间我们两个人满脑子都是轮子，考虑 NIO 考虑session的实现，聊到深夜，也与我反复重构了这个项目。
还有就是 offer 收割机表哥，他帮我指出了一个问题，就是 NIO selector 的注册不是并发的，当时我看 WebServer 的作者的时候也没有仔细思考。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/translate%E7%BF%BB%E8%AF%91%E4%BD%9C%E5%93%81/equals-%E5%92%8C-hashcode-%E6%96%B9%E6%B3%95%E5%9C%A8java%E4%B8%AD%E7%9A%84%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/translate%E7%BF%BB%E8%AF%91%E4%BD%9C%E5%93%81/equals-%E5%92%8C-hashcode-%E6%96%B9%E6%B3%95%E5%9C%A8java%E4%B8%AD%E7%9A%84%E5%85%B3%E7%B3%BB/</guid>
      <description>Java.lang.object 定义了两个非常重要的方法:
 public boolean equals(Object obj) public int hashCode()  equals() 方法 在Java 中 equals()是用来比较两个对象是否相等。主要分为两个方面的比较:
 浅比较(Shallow comparison):在Java.lang.Object 类中默认的实现是简单的比较两个引用(假设是x和y)是否指向同样的对象。由于Object类没有定义其状态的数据成员，所以也称之为浅比较(Shallow comparison)。 深比较(Deep Comparison):假设一个类提供了拥有对equals()方法的自己的实现，目的去比较具有w.r.t状态的对象。意思是对象中的数据成员(例如:域)将会被比较。基于数据成员的比较方式叫做深比较(Deep Comparison)。  语法:
public boolean equals (Object obj) // This method checks if some other Object // passed to it as an argument is equal to // the Object on which it is invoked. //此方法检查是否有其他Object //作为参数传递给它等于 //调用它的Object。 Object类中一些关于equals()的原则:如果某个其他对象等于给定对象，则它遵循以下规则：
 自反性：对于任何引用a,a.equals(a)应该返回true。 对称性：对于任何引用a和b，如果a.equals(b)返回true,那么b.equals(a)必须返回true。 传递性:对于任何引用a，b和c，如果a.equals(b)返回true，　并且b.equals(c)返回true，则a.equals(c)应该返回true。 一致性:对于任何应用a和b,多次调用a.equals(b)始终返回true或始终返回false,前提是在没有修改对象equals比较中使用的信息。  注:对于任何非空的引用a,a.equals(null)应该返回false。
class Geek { public String name; public int id; Geek(String name, int id) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/translate%E7%BF%BB%E8%AF%91%E4%BD%9C%E5%93%81/sdk/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/translate%E7%BF%BB%E8%AF%91%E4%BD%9C%E5%93%81/sdk/</guid>
      <description>GrowingIO Marketing API Java Library 概述 GrowingIO Marketing API 的 Java 版本封装库。
对应的 REST API 文档：REST API - Push.
安装 maven 方式 将下边的依赖条件放到你项目的 maven pom.xml 文件里。
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.growingio&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;marketing-api-java-client&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 样例 推送 API  构建推送对象：所有平台，推送目标是别名为 &amp;ldquo;alias1&amp;rdquo;，通知内容为 ALERT。 构建 PushMessage:  // 需要替换成使用者的自己的变量  String clientId = &amp;#34;clientId&amp;#34;; String secret = &amp;#34;secret&amp;#34;; String projectUid = &amp;#34;projectUid&amp;#34;; String ai = &amp;#34;ai&amp;#34;; PushMessageClient client = PushMessageClient.getInstance(clientId, secret, projectUid, ai); Options options = Options.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/work%E5%B7%A5%E4%BD%9C/aes-%E9%99%90%E5%88%B6%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/work%E5%B7%A5%E4%BD%9C/aes-%E9%99%90%E5%88%B6%E9%95%BF%E5%BA%A6/</guid>
      <description>写了一个工具类用来加密解密数据库的 app字段
本地环境运行单测什么都没有任何问题，但是一到生产环境就出现 BUG。
![image-20191109145633818](/Users/xiantang/Library/Application Support/typora-user-images/image-20191109145633818.png)
这个的原因是因为线上环境没有支持 AES 算法的 Provider 需要通过改 ext 包下添加支持的第三方包或者引入第三方库解决。
我这边采用的是引入第三方库：
&amp;#34;org.bouncycastle&amp;#34; % &amp;#34;bcprov-jdk16&amp;#34; % &amp;#34;1.45&amp;#34; private val localCipher: ThreadLocal[Cipher] = ThreadLocal.withInitial(() =&amp;gt; Cipher.getInstance(&amp;#34;AES/ECB/PKCS5Padding&amp;#34;, new BouncyCastleProvider())) 这样就解决了 No installed provider supports this key 的问题。
但是提到了测试环境，又出现了问题:
![image-20191109150457772](/Users/xiantang/Library/Application Support/typora-user-images/image-20191109150457772.png)
显示没有合法的AES key
首先我先将 SEED 的长度设置到16个字符，本地没有问题但是测试环境仍然报错，我突然发现我的 SEED 会进行一次 SHA-256 算法的散列，随后他的字符数目会增加到 32 个。
我们需要明确一下本地环境和线上环境的不同:
 本地: Jdk 安全目录 含有 unlimit 的jar包，也就是支持 16 24 32 位的key 线上: Jdk 安全目录 只含有 limit 的jar包，只支持 16 位的key  有两种解决方式1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/work%E5%B7%A5%E4%BD%9C/docker-skywalking/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/work%E5%B7%A5%E4%BD%9C/docker-skywalking/</guid>
      <description>Docker 部署 SkyWalking OAP &amp;amp; UI ▶ 获取镜像  当前版本：6.1.0 自制镜像：Docker 镜像 - 构建 SkyWalking OAP &amp;amp; UI
 # oap docker pull registry.cn-hangzhou.aliyuncs.com/anoy/skywalking-oap # ui docker pull registry.cn-hangzhou.aliyuncs.com/anoy/skywalking-ui ▶ 部署 SkyWalking OAP 简易部署（仅供体验）
docker run -d \ --name skywalking-oap \ -p 11800:11800 \ -e TZ=Asia/Shanghai \ registry.cn-hangzhou.aliyuncs.com/anoy/skywalking-oap 端口说明
 0.0.0.0/11800：gRPC APIs，用于 Java、.NetCore、Node.js、Istio 探针 0.0.0.0/12800：http rest APIs，用于 SkyWalking UI 请求，做 GraphQL 查询  自定义配置
配置挂载路径 /skywalking/config，配置文件说明：
 application.yml：基本配置，参考 application.yml component-libraries.yml：组件库配置，参考 component-libraries.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/work%E5%B7%A5%E4%BD%9C/k8s-pod/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/work%E5%B7%A5%E4%BD%9C/k8s-pod/</guid>
      <description>Kubernetes对象模型中可部署的最小对象。
了解Pod Pod是Kubernetes创建或部署的最小/最简单的基本单位，一个Pod代表集群上正在运行的一个进程。
一个Pod封装一个应用容器（也可以有多个容器），存储资源、一个独立的网络IP以及管理控制容器运行方式的策略选项。Pod代表部署的一个单位：Kubernetes中单个应用的实例，它可能由单个容器或多个容器共享组成的资源。
 Docker是Kubernetes Pod中最常见的runtime ，Pods也支持其他容器runtimes。
 Kubernetes中的Pod使用可分两种主要方式：
 Pod中运行一个容器。“one-container-per-Pod”模式是Kubernetes最常见的用法; 在这种情况下，你可以将Pod视为单个封装的容器，但是Kubernetes是直接管理Pod而不是容器。 Pods中运行多个需要一起工作的容器。Pod可以封装紧密耦合的应用，它们需要由多个容器组成，它们之间能够共享资源，这些容器可以形成一个单一的内部service单位 - 一个容器共享文件，另一个“sidecar”容器来更新这些文件。Pod将这些容器的存储资源作为一个实体来管理。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/work%E5%B7%A5%E4%BD%9C/pushchannle-work/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/work%E5%B7%A5%E4%BD%9C/pushchannle-work/</guid>
      <description>每个流程都是实现于 EventHandler
Called when a publisher has published an event to the RingBuffer
public interface EventHandler&amp;lt;T&amp;gt; { /***Called when a publisher has published an event to the {@link RingBuffer} **@param event published to the {@link RingBuffer} *@param sequence of the event being processed *@param endOfBatch flag to indicate if this is the last event in a batch from the {@link RingBuffer} *@throws Exception if the EventHandler would like the exception handled further up the chain.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/work%E5%B7%A5%E4%BD%9C/qlb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/work%E5%B7%A5%E4%BD%9C/qlb/</guid>
      <description>术语解析:
负载调度器（Load Balancer）:负载调度器能无缝地将网络请求调度到真实服务器上，从而使得服务器集群的结构对客户是透明的，客户访问集群系统提供的网络服务就像访 问一台高性能、高可用的服务器一样。客户程序不受服务器集 群的影响不需作任何修改。系统的伸缩性通过在服务机群中透明地加入和删除一个节点来达到，通过检 测节点或服务进程故障和正确地重置系统达到高可用性。
LVS: Linux 虚拟服务器(Linux Virtual Server) 负载调度技术在内核中实现。
LVS 负载均衡技术   NAT
通过网络地址转换，调度器重写请求报文的目标地址，根据预设的算法，将请求分派给后端的真实服务器。真实服务器的响应报文通过调度器时，报文的源地址被重写，再返回给客户，完成整个负载调度过程。
  DR
通过改写请求报文的MAC地址，将请求发送到真实服务器，而真实服务器将响应直接返回给客户。可以极大的提高集群系统的伸缩性。这种方法没有IP隧道的开销，对集群中的真实服务器也没有必须支持IP隧道协议的要求，但是要求调度器与真实服务器都有一块网卡连 在同一物理网段上。
  LVS集群的特点 功能 支持持久的虚拟化服务，并提供详尽的统计数据。能及时将故障屏蔽，实现系统的高可用性。主、从调度器能周期性地进行状态同步，从而实现更高的可用性。
适用性 后端服务器可运行任何支持TCP/IP的操作系统，包括Linux，各种Unix（如FreeBSD、Sun Solaris、HP Unix等），Mac/OS和Windows NT/2000等。
负载调度器能够支持绝大多数的TCP和UDP协议：
   协议 内 容     TCP HTTP，FTP，PROXY，SMTP，POP3，IMAP4，DNS，LDAP，HTTPS，SSMTP等   UDP DNS，NTP，ICP，视频、音频流播放协议等    集群模式 主备 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/work%E5%B7%A5%E4%BD%9C/qs-%E6%9F%A5%E8%AF%A2%E9%87%8D%E8%AF%95%E7%AD%96%E7%95%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/work%E5%B7%A5%E4%BD%9C/qs-%E6%9F%A5%E8%AF%A2%E9%87%8D%E8%AF%95%E7%AD%96%E7%95%A5/</guid>
      <description>方案:
1.对于查询 QueryActor 的失败查询，传入封装好的 GroupUsersRequest 内部包含对应的请求偏移量给 重试的Actor
2.通过模式匹配获得数组的第一个睡眠的时间长度，随后先执行睡眠操作，因为上一次的重试或者QueryActor 刚刚结束。
3.随后执行对应的请求操作，判断是否成功。
4.如果重试成功，记录当前重试的次数，与重试的总计用时，以及GroupUsersRequest 中的ai，查询的url ，写入retry_qs_invoke 表中,随后对成功的数据执行 QueryActor 相同的逻辑，对数据根据channel 分类随后建立 JobContext 交付给 checkpointTaskActor 处理，逻辑和 QueryActor 查询成功的逻辑类似。 5.A:如果重试失败，并且剩下的重试 List 为空，就记录重试的总计用时，以及GroupUsersRequest 中的 ai，查询的url ，写入 retry_qs_invoke 表中。B:如果重试失败，并且剩下的List不为空，就将剩下的List 与 GroupUsersRequest 传入 RetryActor 调用自己。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/work%E5%B7%A5%E4%BD%9C/release-%E7%8E%AF%E5%A2%83remote-debug/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/work%E5%B7%A5%E4%BD%9C/release-%E7%8E%AF%E5%A2%83remote-debug/</guid>
      <description>JAVA_OPTIONS=&amp;#34;-server -XX:+UseG1GC -Xmx512M -XX:MaxDirectMemorySize=128M&amp;#34; =&amp;gt;
JAVA_OPTIONS=&amp;#34;-server -XX:+UseG1GC -Xmx512M -XX:MaxDirectMemorySize=128M -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5005&amp;#34; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/work%E5%B7%A5%E4%BD%9C/scala-i18%E5%9D%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/work%E5%B7%A5%E4%BD%9C/scala-i18%E5%9D%91/</guid>
      <description>i18n 无法加入编译 Can&amp;rsquo;t find bundle for base name filename.properties, locale ch_CN
真的坑
是因为编译没把资源文件编译进去
复制resource里面 注意是里面!!!! 的文件到 target/scala-2.12 文件夹下面</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/work%E5%B7%A5%E4%BD%9C/sonar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/work%E5%B7%A5%E4%BD%9C/sonar/</guid>
      <description>安装 SonarScanner https://docs.sonarqube.org/latest/analysis/scan/sonarscanner/
下载Mac OS X 64-bit 版本
配置环境变量
vim ~/.bash_profile export SONAR_SCANNER_HOME=/yourpath/sonar-scanner-4.2.0.1873-macosx/ source ~/.bash_profile Plugin.sbt
addSbtPlugin(&amp;#34;com.github.mwz&amp;#34; % &amp;#34;sbt-sonar&amp;#34; % &amp;#34;1.3.0&amp;#34;) addSbtPlugin(&amp;#34;com.github.sbt&amp;#34; % &amp;#34;sbt-jacoco&amp;#34; % &amp;#34;3.1.0&amp;#34;) sonar-project.properties
# more parameters https://docs.sonarqube.org/display/SONAR/Analysis+Parameters # must be unique in a given SonarQube instance sonar.projectKey=com.growingio:growing-marketing # this is the name and version displayed in the SonarQube UI. Was mandatory prior to SonarQube 6.1. sonar.projectName=growing-marketing sonar.projectVersion=1.0 sonar.host.url = http://sonarqube.growingio.com # Path is relative to the sonar-project.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/work%E5%B7%A5%E4%BD%9C/vpn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/work%E5%B7%A5%E4%BD%9C/vpn/</guid>
      <description>当前配置
VPN 不走全局流量</description>
    </item>
    
  </channel>
</rss>