<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm(算法)s on xiantang</title>
    <link>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in Algorithm(算法)s on xiantang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/dp-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/dp-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/</guid>
      <description>我们主要通过三道子序列问题来分析 首先DP区间问题可以通过大问题划分成最优的子结构来解决。 也就是说每个最终解都是从子问题开始的。
  516.longest-palindromic-subsequence Given a string s, find the longest palindromic subsequence&amp;rsquo;s length in s. 我们采用一个二维的数组来记录历史，dp[i][j]表示的是索引i-j之间的最大字串。 我们可以发现下面三个情况:
 len=1 的时候表示dp[i][j]就只有一个字符，dp[i][j]=1 str[i]==str[j]就表示是回文，dp[i][j] = dp[i+1][j-1]+2 否则不是在前就是在后。  针对如何遍历所有序列我们采用这样的方式
for(int len=1;len&amp;lt;=s.length();len++){ // 起始位置  for(int i=0;i&amp;lt;=s.length()-len;i++){ // j的位置  int j = i+len-1; // do something  } }   </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/leetcode-todo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/leetcode-todo/</guid>
      <description>链表    链表的必备知识要点(包括基础知识、刷题中使用的STL等知识)     链表逆序(LeetCode 92,206. Reverse Linked List 1,2)     求两个链表的交点(LeetCode 160. Intersection of Two Linked Lists)     链表的节点交换(LeetCode 24. Swap Nodes in Pairs)     链表求环(LeetCode 141,142. Linked List Cycle 1,2)     链表重新构造(LeetCode 86. Partition List)     复杂的链表复制(LeetCode 138. Copy List with Random Pointer)     排序链表合并(2个与多个) (LeetCode 21,23 Merge Two(k) Sorted ListsLeetCode)    栈、队列、堆    栈、队列知识要点与实现(数组、链表)     使用队列实现栈(LeetCode 232.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/tree/</guid>
      <description>霍夫曼树 霍夫曼树又称最优二叉树，是一种带权路径长度最短的二叉树。
 根据给定的n个权值(W1,W2&amp;hellip;Wn)，使对应节点构成n个二叉树的森林T=(T1,T2&amp;hellip;Tn)，其中每个二叉树Ti(1 &amp;lt;= i &amp;lt;= n)中都有一个带权值为Wi的根节点，其左、右子树均为空。 在森林T中选取两个节点权值最小的子树，分别作为左、右子树构造一个新的二叉树，且置新的二叉树的根节点的权值为其左右子树上根节点权值之和。 在森林T中，用新得到的二叉树替代选取的两个二叉树。 重复2和3，直到T只包含一个树为止。这个数就是霍夫曼树。  平衡二叉树 它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
![âå¹³è¡¡äºåæ âçå¾çæç´¢ç»æ](../../images/Sun, 26 May 2019 235539.jpeg)
AVL   它的左子树和右子树都是平衡二叉树。
  左子树和右子树的深度之差的绝对值不超过1。
  B-树  所有叶子结点位于同一层，并且 不带信息。 树中每个节点最多有m个子树(即至多含有m-1个关键字)。 若根节点不是终端节点，则根节点子树[2,m]. 除根节点外其他非叶子节点至少有[m/2]个子树(即至少含有[m/2]-1个关键字)。 ![âb-æ âçå¾çæç´¢ç»æ](../../images/Sun, 26 May 2019 235747.jpeg)  B树 和 B+树的区别  B+树种所有叶子节点包含了全部关键字，即其他非叶子节点中的关键字包含在叶子节点中，而在B-树中，关键字是不重复的。 B+树中所有非叶子节点仅起到索引的作用  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/</guid>
      <description>78. Subsets Given a set of distinct integers, nums, return all possible subsets (the power set).Note: The solution set must not contain duplicate subsets.Example:
 Input: nums = [1,2,3] Output: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] 这种解法是 CareerCup 书上给的一种解法，想法也比较巧妙，把数组中所有的数分配一个状态，true 表示这个数在子集中出现，false 表示在子集中不出现，那么对于一个长度为n的数组，每个数字都有出现与不出现两种情况，所以共有 2n 中情况，那么我们把每种情况都转换出来就是子集了，我们还是用题目中的例子, [1 2 3] 这个数组共有8个子集，每个子集的序号的二进制表示，把是1的位对应原数组中的数字取出来就是一个子集，八种情况都取出来就是所有的子集了，参见代码如下
class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsets(int[] nums) { int n = nums.length; List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); for(int s=0;s&amp;lt; 1&amp;lt;&amp;lt;n;s++){ List&amp;lt;Integer&amp;gt; cur = new ArrayList&amp;lt;&amp;gt;(); for(int i=0;i&amp;lt;n;i++){ if((s &amp;amp; (1 &amp;lt;&amp;lt; i))&amp;gt;0){ cur.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E5%89%91%E5%80%BCoffer-%E5%88%B7%E9%A2%98%E9%9B%86%E5%90%88/%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E5%89%91%E5%80%BCoffer-%E5%88%B7%E9%A2%98%E9%9B%86%E5%90%88/%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>二叉树中和为某一值的路径 题目描述 输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)
import java.util.*; /** public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } */ public class Solution { public ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; result; public ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; FindPath(TreeNode root,int target) { result = new ArrayList&amp;lt;&amp;gt;(); find(root,target,new ArrayList&amp;lt;Integer&amp;gt;()); return result; } public void find(TreeNode root,int target,ArrayList&amp;lt;Integer&amp;gt; current) { if(root == null){ return; } if(root.val == target &amp;amp;&amp;amp; root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E5%89%91%E5%80%BCoffer-%E5%88%B7%E9%A2%98%E9%9B%86%E5%90%88/%E5%9B%9E%E6%BA%AF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E5%89%91%E5%80%BCoffer-%E5%88%B7%E9%A2%98%E9%9B%86%E5%90%88/%E5%9B%9E%E6%BA%AF/</guid>
      <description>字符串的排列 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。
可以画出一个递归树
每次递归都将当前的字母和之后的字母交换，然后不断深入。
import java.util.*; public class Solution { private ArrayList&amp;lt;String&amp;gt; result; private TreeSet&amp;lt;String&amp;gt; paths = new TreeSet&amp;lt;&amp;gt;(); public ArrayList&amp;lt;String&amp;gt; Permutation(String str) { result = new ArrayList&amp;lt;&amp;gt;(); if(str .equals(&amp;#34;&amp;#34;) ){ return result; } find(str,0); result.addAll(paths); return result; } public void find(String str,int index){ if(index == str.length()){ paths.add(str); return; } for(int i = index;i&amp;lt;str.length();i++){ char[] array = str.toCharArray(); char tmp = array[index]; array[index] = array[i]; array[i] = tmp; str = new String(array); find(str,index+1); } } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E5%9B%BE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E5%9B%BE/</guid>
      <description>133.Clone Graph Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors.
 Input: {&amp;quot;$id&amp;quot;:&amp;quot;1&amp;quot;,&amp;quot;neighbors&amp;quot;:[{&amp;quot;$id&amp;quot;:&amp;quot;2&amp;quot;,&amp;quot;neighbors&amp;quot;:[{&amp;quot;$ref&amp;quot;:&amp;quot;1&amp;quot;},{&amp;quot;$id&amp;quot;:&amp;quot;3&amp;quot;,&amp;quot;neighbors&amp;quot;:[{&amp;quot;$ref&amp;quot;:&amp;quot;2&amp;quot;},{&amp;quot;$id&amp;quot;:&amp;quot;4&amp;quot;,&amp;quot;neighbors&amp;quot;:[{&amp;quot;$ref&amp;quot;:&amp;quot;3&amp;quot;},{&amp;quot;$ref&amp;quot;:&amp;quot;1&amp;quot;}],&amp;quot;val&amp;quot;:4}],&amp;quot;val&amp;quot;:3}],&amp;quot;val&amp;quot;:2},{&amp;quot;$ref&amp;quot;:&amp;quot;4&amp;quot;}],&amp;quot;val&amp;quot;:1} Explanation: Node 1&#39;s value is 1, and it has two neighbors: Node 2 and 4. Node 2&#39;s value is 2, and it has two neighbors: Node 1 and 3. Node 3&#39;s value is 3, and it has two neighbors: Node 2 and 4.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E6%A0%88%E9%98%9F%E5%88%97%E5%A0%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E6%A0%88%E9%98%9F%E5%88%97%E5%A0%86/</guid>
      <description>232. Implement Queue using Stacks Implement the following operations of a queue using stacks.push(x)
 Push element x to the back of queue.pop() Removes the element from in front of queue.peek() Get the front element.empty() Return whether the queue is empty.  Example:
 MyQueue queue = new MyQueue(); queue.push(1); queue.push(2); queue.peek(); // returns 1 queue.pop(); // returns 1 queue.empty(); // returns false 这里我采用的是双栈法 入栈的时间复杂度是O(1)
出栈的时间复杂度是O(N)
我们采用一个top 去记录栈底部的数据，然后移动栈的时候当栈1的容量为0 这个元素就是top
class MyQueue { private Stack&amp;lt;Integer&amp;gt; stack1; private Stack&amp;lt;Integer&amp;gt; stack2; private int top = -1; /** Initialize your data structure here.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/</guid>
      <description>\2. 买苹果最少袋子数-贪心法
\3. 线性排列正方形的最少涂染数-辅助数组
\4. N阶方阵中最大正方形边长-辅助数组
\5. 指定概率数字生成函数-构造概率函数，数学题
6.给定非负整数n能形成的二叉树结构数目-左右子树加上根节点，递归或者动态规划
7.构成完整括号字符串的最少添加括号数-2个变量计数
8.差值为k的去重数字对-哈希
9.最大magic操作数-贪心
10.可以转换的不同字符串的个数-动态规划
11.括号序列的深度-动态规划
12.栈的升序排序-栈
13.青草游戏-打表
14.根节点到叶节点权值最大-树形dp
15.打包机器-贪心
16.zipzap打印矩阵-模拟
17.螺旋打印矩阵-模拟
18.顺时针选择矩阵-模拟
19.有序二维数组找书-模拟
20.拼接出长度n的最小操作数-分类讨论
21.找出现次数最多前k个字符串-堆
22.狗猫队列-队列哈希
23.返回栈中最小元素-栈
24.栈队列转换-栈、队列
25.动态规划空间压缩
26.容器灌水-栈
27.左右部分最大绝对值之差-队列
28.旋转词-kmp算法
29.附加题-斐波那契数列矩阵乘法
30.达标字符串数量-斐波那契数列
31.删除木棒数-贪心、斐波那契数列
32.调整数列两两相乘为4的倍数-思维题
33.判断字符串是否为整数-正则表达式
34.TopKRecord结构-背包
35.放进背包的零食种数-动态规划
36.牛牛找工作-贪心
37.画目录结构-字母多叉树
38.搜索二叉树转换有序双向列表-思维题
39.最大搜索二叉子树的节点个数-树形结构
40.返回后序遍历-递归
41.安置路灯-贪心，动态规划
42.帖子最高分数-动态规划
43.子矩阵的最大累计和-思维题
44.数字用中文表示-模拟
45.找到[1,n]中所有未出现在A中的整数-数组
46.神奇的数列-思维题
47.送C币-贪心
48.求完全二叉树节点的个数-递归
49.cc直播运营活动-bfs
50.最长递增子序列问题-动态规划
51.最大子数组异或和-动态规划
52.express组合成desired的方案数-区间动归
53.字典序问题-暴力
54.无重复字符子串中最长的长度-滑动窗口
55.最小编辑代价-动态规划
56.删字符-贪心
57.字符串变换-bfs
58.可变更缓存结构-哈希、双向链表
59.求一条直线最多能穿过多少个点-枚举
60.最少的跳跃次数跳到最后一个数-贪心
61.两个数相加和最大的前k个-思维题
62.数组分成4部分-二分答案
63.判断字符串是否为交错组成-动态规划
64.找丑数-模拟
65.需要排序的最短子数组长度-思维题
66.最小不可组成和-动态规划
67.组成区间缺少的数-动态规划</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E8%B2%AA%E5%BF%83/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E8%B2%AA%E5%BF%83/</guid>
      <description>455. Assign Cookies Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj &amp;gt;= gi, we can assign the cookie j to the child i, and the child i will be content.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/algorithm%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/</guid>
      <description>92. Reverse Linked List II Reverse a linked list from position m to n. Do it in one-pass.
Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, m = 2, n = 4 Output: 1-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;5-&amp;gt;NULL 代码:
class Solution { public ListNode reverseBetween(ListNode head, int m, int n) { if(head == null) { return null; } ListNode dummy = new ListNode(0); dummy.next = head; ListNode pre = dummy; for(int i = 0 ; i&amp;lt;m-1;i++){ pre = pre.next; } ListNode start = pre.</description>
    </item>
    
  </channel>
</rss>