<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>xiantang </title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.63.0-DEV" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.3f5912c237ddd38c8e76debe081c7ca7.css" rel="stylesheet">
    

    

    
      
    

    
    
    <meta property="og:title" content="" />
<meta property="og:description" content="接收器 阀
Tomcat 自带线程池
HTTP Web 服务器也称为超文本传输协议服务器，因为他使用HTTP 与其客户端进行通讯。
HTTP 是应用层协议，由响应和请求组成，是一个标准的B/S 模型,同时也是一个无状态的协议，在同一个客户端中，此次请求和上次请求没有对应关系。
HTTP 允许Web服务器和浏览器通过Internet 发送请求，他是一种基于“请求－响应”的协议。客户端请求一个文件，服务端对于该请求进行响应。
HTTP 请求 一个HTTP 请求包括三部分:
 请求方法－－－统一资源标识符 URI 协议／版本 请求头 实体  POST /ajax/ShowCaptcha HTTP/1.1\r\n Content-Type: application/x-www-form-urlencoded\r\n Host: www.renren.com\r\n Content-Length: 36\r\n \r\n email=%E5%B7%A5&amp;password=asdasdsadas 请求方法 －－ URI －－ 协议／版本
POST /ajax/ShowCaptcha HTTP/1.1\r\n
会出现在第一行
每个请求头之前都会用回车／换行符隔开 (CRLF)
并且请求头和请求实体之间会有一个空行，空行只有 CRLF 符号。CRLF告诉HTTP服务器请求的正文从哪里开始。
HTTP 响应 与HTTP 请求相似，HTTP 响应也分三部分:
 协议－－ 状态码 响应头 响应实体段  HTTP/1.1 200 OK\r\n Date: Sat, 31 Dec 2005 23:59:59 GMT\r\n Content-Type: text/html;charset=ISO-8859-1\r\n Content-Length: 122\r\n \r\n &lt;html&gt; &lt;head&gt; &lt;title&gt;Wrox Homepage&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xiantang.github.io/tomcat/tomcat-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-1-httprequestresponse/" />

<meta itemprop="name" content="">
<meta itemprop="description" content="接收器 阀
Tomcat 自带线程池
HTTP Web 服务器也称为超文本传输协议服务器，因为他使用HTTP 与其客户端进行通讯。
HTTP 是应用层协议，由响应和请求组成，是一个标准的B/S 模型,同时也是一个无状态的协议，在同一个客户端中，此次请求和上次请求没有对应关系。
HTTP 允许Web服务器和浏览器通过Internet 发送请求，他是一种基于“请求－响应”的协议。客户端请求一个文件，服务端对于该请求进行响应。
HTTP 请求 一个HTTP 请求包括三部分:
 请求方法－－－统一资源标识符 URI 协议／版本 请求头 实体  POST /ajax/ShowCaptcha HTTP/1.1\r\n Content-Type: application/x-www-form-urlencoded\r\n Host: www.renren.com\r\n Content-Length: 36\r\n \r\n email=%E5%B7%A5&amp;password=asdasdsadas 请求方法 －－ URI －－ 协议／版本
POST /ajax/ShowCaptcha HTTP/1.1\r\n
会出现在第一行
每个请求头之前都会用回车／换行符隔开 (CRLF)
并且请求头和请求实体之间会有一个空行，空行只有 CRLF 符号。CRLF告诉HTTP服务器请求的正文从哪里开始。
HTTP 响应 与HTTP 请求相似，HTTP 响应也分三部分:
 协议－－ 状态码 响应头 响应实体段  HTTP/1.1 200 OK\r\n Date: Sat, 31 Dec 2005 23:59:59 GMT\r\n Content-Type: text/html;charset=ISO-8859-1\r\n Content-Length: 122\r\n \r\n &lt;html&gt; &lt;head&gt; &lt;title&gt;Wrox Homepage&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!">

<meta itemprop="wordCount" content="1248">



<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="接收器 阀
Tomcat 自带线程池
HTTP Web 服务器也称为超文本传输协议服务器，因为他使用HTTP 与其客户端进行通讯。
HTTP 是应用层协议，由响应和请求组成，是一个标准的B/S 模型,同时也是一个无状态的协议，在同一个客户端中，此次请求和上次请求没有对应关系。
HTTP 允许Web服务器和浏览器通过Internet 发送请求，他是一种基于“请求－响应”的协议。客户端请求一个文件，服务端对于该请求进行响应。
HTTP 请求 一个HTTP 请求包括三部分:
 请求方法－－－统一资源标识符 URI 协议／版本 请求头 实体  POST /ajax/ShowCaptcha HTTP/1.1\r\n Content-Type: application/x-www-form-urlencoded\r\n Host: www.renren.com\r\n Content-Length: 36\r\n \r\n email=%E5%B7%A5&amp;password=asdasdsadas 请求方法 －－ URI －－ 协议／版本
POST /ajax/ShowCaptcha HTTP/1.1\r\n
会出现在第一行
每个请求头之前都会用回车／换行符隔开 (CRLF)
并且请求头和请求实体之间会有一个空行，空行只有 CRLF 符号。CRLF告诉HTTP服务器请求的正文从哪里开始。
HTTP 响应 与HTTP 请求相似，HTTP 响应也分三部分:
 协议－－ 状态码 响应头 响应实体段  HTTP/1.1 200 OK\r\n Date: Sat, 31 Dec 2005 23:59:59 GMT\r\n Content-Type: text/html;charset=ISO-8859-1\r\n Content-Length: 122\r\n \r\n &lt;html&gt; &lt;head&gt; &lt;title&gt;Wrox Homepage&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!"/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://xiantang.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      xiantang
    </a>
    <div class="flex-l items-center">
      

      
      













    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        TOMCATS
      </p>
      <h1 class="f1 athelas mb1"></h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="0001-01-01T00:00:00Z">January 1, 0001</time>
      
      
    </header>

    <section class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p>接收器 阀</p>
<p>Tomcat 自带线程池</p>
<h1 id="http">HTTP</h1>
<p>Web 服务器也称为超文本传输协议服务器，因为他使用HTTP 与其客户端进行通讯。</p>
<p>HTTP 是应用层协议，由响应和请求组成，是一个标准的B/S 模型,同时也是一个无状态的协议，在同一个客户端中，此次请求和上次请求没有对应关系。</p>
<p>HTTP 允许Web服务器和浏览器通过Internet 发送请求，他是一种基于“请求－响应”的协议。客户端请求一个文件，服务端对于该请求进行响应。</p>
<h2 id="http-请求">HTTP 请求</h2>
<p>一个HTTP 请求包括三部分:</p>
<ul>
<li>请求方法－－－统一资源标识符 URI  协议／版本</li>
<li>请求头</li>
<li>实体</li>
</ul>
<pre><code>POST /ajax/ShowCaptcha HTTP/1.1\r\n
Content-Type: application/x-www-form-urlencoded\r\n
Host: www.renren.com\r\n
Content-Length: 36\r\n
\r\n
email=%E5%B7%A5&amp;password=asdasdsadas
</code></pre><p>请求方法 －－ URI －－ 协议／版本</p>
<p>POST /ajax/ShowCaptcha HTTP/1.1\r\n</p>
<p>会出现在第一行</p>
<p>每个请求头之前都会用回车／换行符隔开 (CRLF)</p>
<p>并且请求头和请求实体之间会有一个空行，空行只有 CRLF 符号。CRLF告诉HTTP服务器请求的正文从哪里开始。</p>
<h2 id="http-响应">HTTP 响应</h2>
<p>与HTTP 请求相似，HTTP 响应也分三部分:</p>
<ul>
<li>协议－－ 状态码</li>
<li>响应头</li>
<li>响应实体段</li>
</ul>
<pre><code>HTTP/1.1 200 OK\r\n
Date: Sat, 31 Dec 2005 23:59:59 GMT\r\n
Content-Type: text/html;charset=ISO-8859-1\r\n
Content-Length: 122\r\n
\r\n
&lt;html&gt;

&lt;head&gt;
&lt;title&gt;Wrox Homepage&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;!-- body goes here --&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>HTTP/1.1 200 OK
Date: Sat, 31 Dec 2005 23:59:59 GMT
Content-Type: text/html;charset=ISO-8859-1
Content-Length: 122</p>
<!-- raw HTML omitted -->
<p>第一行类似使用的协议以及状态码（200 表示请求成功</p>
<h2 id="standardserver">StandardServer</h2>
<p>此类是Server 标准实现类，Server 仅此一个实现类。是Tomcat 顶级容器。Server是Tomcat中最顶层的组件，它可以包含多个Service组件。这一节主要给大家讲解Tomcat 是如何关闭的。之后的章节会给大家带来addService() 和findService（String) 方法的解析。</p>
<p>这个<code>StandardServer</code> 继承了 <code>Server</code></p>
<p>并且实现了其中比较关键的一个方法:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"> <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Wait until a proper shutdown command is received, then return.
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">await</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
</code></pre></div><p>z</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
      InputStream stream<span style="color:#f92672">;</span>
      <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
        socket <span style="color:#f92672">=</span> serverSocket<span style="color:#f92672">.</span><span style="color:#a6e22e">accept</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
        socket<span style="color:#f92672">.</span><span style="color:#a6e22e">setSoTimeout</span><span style="color:#f92672">(</span>10 <span style="color:#f92672">*</span> 1000<span style="color:#f92672">)</span><span style="color:#f92672">;</span>  <span style="color:#75715e">// Ten seconds
</span><span style="color:#75715e"></span>        stream <span style="color:#f92672">=</span> socket<span style="color:#f92672">.</span><span style="color:#a6e22e">getInputStream</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
      <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>AccessControlException ace<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        log<span style="color:#f92672">.</span><span style="color:#a6e22e">warn</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;StandardServer.accept security exception: &#34;</span>
                 <span style="color:#f92672">+</span> ace<span style="color:#f92672">.</span><span style="color:#a6e22e">getMessage</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">,</span> ace<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">continue</span><span style="color:#f92672">;</span>
      <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>IOException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>stopAwait<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
          <span style="color:#75715e">// Wait was aborted with socket.close()
</span><span style="color:#75715e"></span>          <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        log<span style="color:#f92672">.</span><span style="color:#a6e22e">error</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;StandardServer.await: accept: &#34;</span><span style="color:#f92672">,</span> e<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
      <span style="color:#f92672">}</span>
      <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>expected <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> ch <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
          ch <span style="color:#f92672">=</span> stream<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>IOException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
          log<span style="color:#f92672">.</span><span style="color:#a6e22e">warn</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;StandardServer.await: read: &#34;</span><span style="color:#f92672">,</span> e<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
          ch <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>ch <span style="color:#f92672">&lt;</span> 32<span style="color:#f92672">)</span>  <span style="color:#75715e">// Control character or EOF terminates loop
</span><span style="color:#75715e"></span>          <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
        command<span style="color:#f92672">.</span><span style="color:#a6e22e">append</span><span style="color:#f92672">(</span><span style="color:#f92672">(</span><span style="color:#66d9ef">char</span><span style="color:#f92672">)</span> ch<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
        expected<span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">;</span>
      <span style="color:#f92672">}</span><span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// Close the socket now that we are done with it
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
          <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>socket <span style="color:#f92672">!</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            socket<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
          <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>IOException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
          <span style="color:#75715e">// Ignore
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
      <span style="color:#f92672">}</span>
  		 <span style="color:#75715e">// Match against our command string
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">boolean</span> match <span style="color:#f92672">=</span> command<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>shutdown<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>match<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        log<span style="color:#f92672">.</span><span style="color:#a6e22e">info</span><span style="color:#f92672">(</span>sm<span style="color:#f92672">.</span><span style="color:#a6e22e">getString</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;standardServer.shutdownViaPort&#34;</span><span style="color:#f92672">)</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
      <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span>
        log<span style="color:#f92672">.</span><span style="color:#a6e22e">warn</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;StandardServer.await: Invalid command &#39;&#34;</span>
                 <span style="color:#f92672">+</span> command<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&#39; received&#34;</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
  
</code></pre></div><p>根据源码上的注释 我们可以大致了解，在启动Tomcat 的时候，会开启一个8005的端口，这个服务负责监听到来的 telnet 连接，当受到 为SHUTDOWN  的命令时候，销毁Tomcat 的所有服务并且关闭Tomcat。</p>
<h1 id="request--response">Request &amp; Response</h1>
<p>在阅读Tomcat Request 源码的时候，我发现了一个比较有趣的东西:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> MessageBytes schemeMB <span style="color:#f92672">=</span> MessageBytes<span style="color:#f92672">.</span><span style="color:#a6e22e">newInstance</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
<span style="color:#66d9ef">private</span> MessageBytes methodMB <span style="color:#f92672">=</span> MessageBytes<span style="color:#f92672">.</span><span style="color:#a6e22e">newInstance</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
<span style="color:#66d9ef">private</span> MessageBytes unparsedURIMB <span style="color:#f92672">=</span> MessageBytes<span style="color:#f92672">.</span><span style="color:#a6e22e">newInstance</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
<span style="color:#66d9ef">private</span> MessageBytes uriMB <span style="color:#f92672">=</span> MessageBytes<span style="color:#f92672">.</span><span style="color:#a6e22e">newInstance</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
<span style="color:#66d9ef">private</span> MessageBytes decodedUriMB <span style="color:#f92672">=</span> MessageBytes<span style="color:#f92672">.</span><span style="color:#a6e22e">newInstance</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
<span style="color:#66d9ef">private</span> MessageBytes queryMB <span style="color:#f92672">=</span> MessageBytes<span style="color:#f92672">.</span><span style="color:#a6e22e">newInstance</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
<span style="color:#66d9ef">private</span> MessageBytes protoMB <span style="color:#f92672">=</span> MessageBytes<span style="color:#f92672">.</span><span style="color:#a6e22e">newInstance</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
<span style="color:#75715e">// remote address/host
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> MessageBytes remoteAddrMB <span style="color:#f92672">=</span> MessageBytes<span style="color:#f92672">.</span><span style="color:#a6e22e">newInstance</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
<span style="color:#66d9ef">private</span> MessageBytes localNameMB <span style="color:#f92672">=</span> MessageBytes<span style="color:#f92672">.</span><span style="color:#a6e22e">newInstance</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
<span style="color:#66d9ef">private</span> MessageBytes remoteHostMB <span style="color:#f92672">=</span> MessageBytes<span style="color:#f92672">.</span><span style="color:#a6e22e">newInstance</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
<span style="color:#66d9ef">private</span> MessageBytes localAddrMB <span style="color:#f92672">=</span> MessageBytes<span style="color:#f92672">.</span><span style="color:#a6e22e">newInstance</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
</code></pre></div><p>他的大多数成员变量都是<code>MessageBytes</code> 的实例，这让我产生了兴趣，这个<code>MessageBytes</code>到底是什么东西?</p>
<p>后来通过查阅资料发现Tomcat 为了提升性能，用了一些很有趣的 Tricks</p>
<p>Tomcat 对于读取来的字节流不会立马解析，而是将它进行打标＋延时提取的方式来实现 按需使用。</p>
<p>下面我来跑一个小 demo 来了解一下MessageBytes 是个什么样的东西?</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MessageBytesTest</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>Str ing<span style="color:#f92672">[</span><span style="color:#f92672">]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        MessageBytes mb <span style="color:#f92672">=</span> MessageBytes<span style="color:#f92672">.</span><span style="color:#a6e22e">newInstance</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
        <span style="color:#75715e">// 等待测试的byte 对象
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span><span style="color:#f92672">]</span> bytes <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;abcdefg&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getBytes</span><span style="color:#f92672">(</span>Charset<span style="color:#f92672">.</span><span style="color:#a6e22e">defaultCharset</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
        <span style="color:#75715e">// 调用`setBytes`对bytes 进行标记
</span><span style="color:#75715e"></span>        mb<span style="color:#f92672">.</span><span style="color:#a6e22e">setBytes</span><span style="color:#f92672">(</span>bytes<span style="color:#f92672">,</span> 2<span style="color:#f92672">,</span> 3<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>mb<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>

    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>这个例子用来提取字节流中的子子节，并将它转换为String</p>
<p>下面我们继续来阅读这个 MessageBytes 到底是何方神圣?</p>
<p>MessageByte 主要有四种类型:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> T_NULL <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
<span style="color:#75715e">/** getType() is T_STR if the the object used to create the MessageBytes
</span><span style="color:#75715e">        was a String */</span>
<span style="color:#75715e">// 表示消息为字符串
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> T_STR  <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>
<span style="color:#75715e">/** getType() is T_STR if the the object used to create the MessageBytes
</span><span style="color:#75715e">        was a byte[] */</span>
<span style="color:#75715e">// 表示消息为字节数组类型
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> T_BYTES <span style="color:#f92672">=</span> 2<span style="color:#f92672">;</span>
<span style="color:#75715e">/** getType() is T_STR if the the object used to create the MessageBytes
</span><span style="color:#75715e">        was a char[] */</span>
<span style="color:#75715e">// 表示消息为字符数组
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> T_CHARS <span style="color:#f92672">=</span> 3<span style="color:#f92672">;</span>

</code></pre></div><ol>
<li><code>T_NULL</code>表示空消息，即消息为<code>null</code></li>
<li><code>T_STR</code>表示消息为字符串类型</li>
<li><code>T_BYTES</code>表示消息为字节数组类型</li>
<li><code>T_CHARS</code>表示消息为字符数组类型</li>
</ol>
<p> 接着我们查看一下构造方法:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e">     * Creates a new, uninitialized MessageBytes object.
</span><span style="color:#75715e">     * Use static newInstance() in order to allow
</span><span style="color:#75715e">     *   future hooks.
</span><span style="color:#75715e">     */</span>
    <span style="color:#75715e">// 使用工厂方法来创建实例
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">MessageBytes</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>它的构造方法是私有的，我们只能通过工厂方法来获取实例</p>
<p>接着我们查看我们demo中使用的方法<code>setBytes</code> 这个是一个关键方法，它负责对bytes 打标。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Sets the content to the specified subarray of bytes.
</span><span style="color:#75715e">     *
</span><span style="color:#75715e">     * @param b the bytes
</span><span style="color:#75715e">     * @param off the start offset of the bytes
</span><span style="color:#75715e">     * @param len the length of the bytes
</span><span style="color:#75715e">     */</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setBytes</span><span style="color:#f92672">(</span><span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span><span style="color:#f92672">]</span> b<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> off<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> len<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//private final ByteChunk byteC=new ByteChunk();
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//private final CharChunk charC=new CharChunk();
</span><span style="color:#75715e"></span>        byteC<span style="color:#f92672">.</span><span style="color:#a6e22e">setBytes</span><span style="color:#f92672">(</span> b<span style="color:#f92672">,</span> off<span style="color:#f92672">,</span> len <span style="color:#f92672">)</span><span style="color:#f92672">;</span>
        type<span style="color:#f92672">=</span>T_BYTES<span style="color:#f92672">;</span>
        hasStrValue<span style="color:#f92672">=</span><span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
        hasHashCode<span style="color:#f92672">=</span><span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
        hasIntValue<span style="color:#f92672">=</span><span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
        hasLongValue<span style="color:#f92672">=</span><span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>它内部调用了 <code>ByteChunk</code> 的<code>setBytes</code>方法,同时设置了<code>type字段</code>。</p>
<p>我们继续向里面走！</p>
<p>发现内部十分简单只是对数组进行了标识。　</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">//非常简单，就是设置一下待标识的字节数组、开始位置、结束位置。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setBytes</span><span style="color:#f92672">(</span><span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span><span style="color:#f92672">]</span> b<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> off<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> len<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        buff <span style="color:#f92672">=</span> b<span style="color:#f92672">;</span>
        start <span style="color:#f92672">=</span> off<span style="color:#f92672">;</span>
        end <span style="color:#f92672">=</span> start<span style="color:#f92672">+</span> len<span style="color:#f92672">;</span>
        isSet<span style="color:#f92672">=</span><span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>同时也印证了我们开头所说，打标记但是没有转码。</p>
<p>i</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// -------------------- MessageBytes --------------------
</span><span style="color:#75715e"></span><span style="color:#75715e">/** Compute the string value
</span><span style="color:#75715e">     * 首先判断是否有缓存的字符串，有的话就直接返回，
</span><span style="color:#75715e">     * 这也是提高性能的一种方式。其次是根据type来选择不同的*Chunk，
</span><span style="color:#75715e">     * 然后调用其toString()方法。那么我们这儿选择ByteChunk.toString()来分析。
</span><span style="color:#75715e">     */</span>
<span style="color:#a6e22e">@Override</span>
<span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">toString</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
  <span style="color:#75715e">// 先取缓存
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span> hasStrValue <span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> strValue<span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span>
  <span style="color:#75715e">// 判断缓存类型
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 设置缓存
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">switch</span> <span style="color:#f92672">(</span>type<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">case</span> T_CHARS<span style="color:#f92672">:</span>
      strValue<span style="color:#f92672">=</span>charC<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
      hasStrValue<span style="color:#f92672">=</span><span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
      <span style="color:#66d9ef">return</span> strValue<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">case</span> T_BYTES<span style="color:#f92672">:</span>
      strValue<span style="color:#f92672">=</span>byteC<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
      hasStrValue<span style="color:#f92672">=</span><span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
      <span style="color:#66d9ef">return</span> strValue<span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span>
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// -------------------- ByteChunk --------------------
</span><span style="color:#75715e"></span><span style="color:#a6e22e">@Override</span>
<span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">toString</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">null</span> <span style="color:#f92672">=</span><span style="color:#f92672">=</span> buff<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>end<span style="color:#f92672">-</span>start <span style="color:#f92672">=</span><span style="color:#f92672">=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span>
  <span style="color:#66d9ef">return</span> StringCache<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">toStringInternal</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>charset <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    charset <span style="color:#f92672">=</span> DEFAULT_CHARSET<span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span>
  <span style="color:#75715e">// 如果我们只有少部分要使用
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 通过打标记＋延时提取的方式
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// new String(byte[], int, int, Charset) takes a defensive copy of the
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// entire byte array. This is expensive if only a small subset of the
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// bytes will be used. The code below is from Apache Harmony.
</span><span style="color:#75715e"></span>  CharBuffer cb<span style="color:#f92672">;</span>
  cb <span style="color:#f92672">=</span> charset<span style="color:#f92672">.</span><span style="color:#a6e22e">decode</span><span style="color:#f92672">(</span>ByteBuffer<span style="color:#f92672">.</span><span style="color:#a6e22e">wrap</span><span style="color:#f92672">(</span>buff<span style="color:#f92672">,</span> start<span style="color:#f92672">,</span> end<span style="color:#f92672">-</span>start<span style="color:#f92672">)</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
  <span style="color:#75715e">// reuturn new String(buff, start, end - start, charset);
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span>cb<span style="color:#f92672">.</span><span style="color:#a6e22e">array</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">,</span> cb<span style="color:#f92672">.</span><span style="color:#a6e22e">arrayOffset</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">,</span> cb<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>需要关注的主要是这三个方法</p>
<p>MB 调用 toString 方法的时候首先会从当前实例中取出缓存，如果没有缓存就调用 ByteChunk 的 toString 方法,设置缓存并且返回。</p>
<p>ByteChunk 的 toString 方法是使用StringCache 的toString 方法 但是其中的主要调用仍然是 StringCache.toStringInternal()</p>
<p>我们来讲解一下这个方法吧!</p>
<p>他使用的是NIO 的 ByteBuffer 根据<code>偏移量</code>和<code>待提取长度</code>进行<code>编码提取转换</code>。</p>
<p>需要注意的是该注释已经给出了使用<code>java.nio.charset.CharSet.decode()</code>代替直接使用<code>new String(byte[], int, int, Charset)</code>的原因。</p>
<p>如果是用默认的 <code>new String(byte[], int, int, Charset)</code> 会对整个byte 进行拷贝，对于一个巨大的byte[] 中我们只需要提取一些些数据，就会带来严重的性能损耗。</p>
<h3 id="request-是如何被解析的">Request 是如何被解析的</h3>
<p>他是如何判断打标的位置的？</p>
<p>下面为以给请求行中的 URI 打标为大家解释</p>
<p>我们要探寻的是:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * Implementation of InputBuffer which provides HTTP request header parsing as
</span><span style="color:#75715e"> * well as transfer decoding.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @author &lt;a href=&#34;mailto:remm@apache.org&#34;&gt;Remy Maucherat&lt;/a&gt;
</span><span style="color:#75715e"> * @author Filip Hanik
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InternalNioInputBuffer</span> <span style="color:#66d9ef">extends</span> AbstractInputBuffer<span style="color:#f92672">&lt;</span>NioChannel<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
   <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">parseRequestLine</span><span style="color:#f92672">(</span><span style="color:#66d9ef">boolean</span> useAvailableDataOnly<span style="color:#f92672">)</span>
        <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>
    		<span style="color:#75715e">//-----省略前面的解析步骤
</span><span style="color:#75715e"></span>      	<span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>parsingRequestLinePhase <span style="color:#f92672">=</span><span style="color:#f92672">=</span> 4<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// Mark the current buffer position
</span><span style="color:#75715e"></span>            
            <span style="color:#66d9ef">int</span> end <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
            <span style="color:#75715e">//
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// Reading the URI
</span><span style="color:#75715e"></span>            <span style="color:#75715e">//
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">boolean</span> space <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#f92672">!</span>space<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">// Read new bytes if needed
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>pos <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> lastValid<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span><span style="color:#f92672">!</span>fill<span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">)</span><span style="color:#f92672">)</span> <span style="color:#75715e">//request line parsing
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>buf<span style="color:#f92672">[</span>pos<span style="color:#f92672">]</span> <span style="color:#f92672">=</span><span style="color:#f92672">=</span> Constants<span style="color:#f92672">.</span><span style="color:#a6e22e">SP</span> <span style="color:#f92672">|</span><span style="color:#f92672">|</span> buf<span style="color:#f92672">[</span>pos<span style="color:#f92672">]</span> <span style="color:#f92672">=</span><span style="color:#f92672">=</span> Constants<span style="color:#f92672">.</span><span style="color:#a6e22e">HT</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    space <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
                    end <span style="color:#f92672">=</span> pos<span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span><span style="color:#f92672">(</span>buf<span style="color:#f92672">[</span>pos<span style="color:#f92672">]</span> <span style="color:#f92672">=</span><span style="color:#f92672">=</span> Constants<span style="color:#f92672">.</span><span style="color:#a6e22e">CR</span><span style="color:#f92672">)</span>
                        <span style="color:#f92672">|</span><span style="color:#f92672">|</span> <span style="color:#f92672">(</span>buf<span style="color:#f92672">[</span>pos<span style="color:#f92672">]</span> <span style="color:#f92672">=</span><span style="color:#f92672">=</span> Constants<span style="color:#f92672">.</span><span style="color:#a6e22e">LF</span><span style="color:#f92672">)</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    <span style="color:#75715e">// HTTP/0.9 style request
</span><span style="color:#75715e"></span>                    parsingRequestLineEol <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
                    space <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
                    end <span style="color:#f92672">=</span> pos<span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span><span style="color:#f92672">(</span>buf<span style="color:#f92672">[</span>pos<span style="color:#f92672">]</span> <span style="color:#f92672">=</span><span style="color:#f92672">=</span> Constants<span style="color:#f92672">.</span><span style="color:#a6e22e">QUESTION</span><span style="color:#f92672">)</span>
                        <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> <span style="color:#f92672">(</span>parsingRequestLineQPos <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">)</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    parsingRequestLineQPos <span style="color:#f92672">=</span> pos<span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
                pos<span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            request<span style="color:#f92672">.</span><span style="color:#a6e22e">unparsedURI</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">.</span><span style="color:#a6e22e">setBytes</span><span style="color:#f92672">(</span>buf<span style="color:#f92672">,</span> parsingRequestLineStart<span style="color:#f92672">,</span> end <span style="color:#f92672">-</span> parsingRequestLineStart<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>parsingRequestLineQPos <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                request<span style="color:#f92672">.</span><span style="color:#a6e22e">queryString</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">.</span><span style="color:#a6e22e">setBytes</span><span style="color:#f92672">(</span>buf<span style="color:#f92672">,</span> parsingRequestLineQPos <span style="color:#f92672">+</span> 1<span style="color:#f92672">,</span> 
                                               end <span style="color:#f92672">-</span> parsingRequestLineQPos <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
                request<span style="color:#f92672">.</span><span style="color:#a6e22e">requestURI</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">.</span><span style="color:#a6e22e">setBytes</span><span style="color:#f92672">(</span>buf<span style="color:#f92672">,</span> parsingRequestLineStart<span style="color:#f92672">,</span> parsingRequestLineQPos <span style="color:#f92672">-</span> parsingRequestLineStart<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
                <span style="color:#75715e">// URL 当解析的时候之前个请求方法执行完之后会找到对应的空格
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// 请求行的开始就就是parseRequestLineStart 开始位置
</span><span style="color:#75715e"></span>                <span style="color:#75715e">//  之后向下寻找空格 并将他标记为end
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// setBytes 的时候只要把开始的位置和长度设置进去就行了
</span><span style="color:#75715e"></span>                request<span style="color:#f92672">.</span><span style="color:#a6e22e">requestURI</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">.</span><span style="color:#a6e22e">setBytes</span><span style="color:#f92672">(</span>buf<span style="color:#f92672">,</span> parsingRequestLineStart<span style="color:#f92672">,</span> end <span style="color:#f92672">-</span> parsingRequestLineStart<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;解析出来的URI为: &#34;</span> <span style="color:#f92672">+</span>request<span style="color:#f92672">.</span><span style="color:#a6e22e">requestURI</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
            parsingRequestLinePhase <span style="color:#f92672">=</span> 5<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>这里主要要了解的是几个变量</p>
<ul>
<li>buf 整条请求头的byte[]</li>
<li>parsingRequestLineStart URI 开始位置</li>
<li>end URI 结束位置</li>
</ul>
<p>上面代码的大致意识是 将parsingRequestLineStart的位置设置为上次解析（解析请求方法）的位置＋1</p>
<p>然后通过遍历buf 寻找从 parsingRequestLineStart 开始的第一个空格。</p>
<p>并且为了避免多余的编码，tomcat 将 <code>空格</code> <code>CR</code> <code>LF</code> 也转换为字节，只要比较字节就能判断是否相同，期间没有任何编码。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e">* CR.
</span><span style="color:#75715e">*/</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">byte</span> CR <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">byte</span><span style="color:#f92672">)</span> <span style="color:#e6db74">&#39;\r&#39;</span><span style="color:#f92672">;</span>
<span style="color:#75715e">/**
</span><span style="color:#75715e">* LF.
</span><span style="color:#75715e">*/</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">byte</span> LF <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">byte</span><span style="color:#f92672">)</span> <span style="color:#e6db74">&#39;\n&#39;</span><span style="color:#f92672">;</span>
<span style="color:#75715e">/**
</span><span style="color:#75715e">* SP.
</span><span style="color:#75715e">*/</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">byte</span> SP <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">byte</span><span style="color:#f92672">)</span> <span style="color:#e6db74">&#39; &#39;</span><span style="color:#f92672">;</span>
</code></pre></div><p>将这些字节流通过setBytes 打标，记住是offset/offset+长度。</p>
<h3 id="总结">总结</h3>
<p>还是开头那句话:</p>
<p>Tomcat 采用延时编码的方式来提升性能，解析完一个Request后，如果没有被利用，变量存储的只是这个字节流的打标，只有在使用的时候才会去编码或者去取缓存。这样有个好处，就是Request 中的信息不是全部要使用的，有时候我们只需要取一部分就行了，所以就可以降低编码的性能消耗。</p>
<h1 id="requestfacade">RequestFacade</h1>
<p>阅读Request 源码的时候我发现他是拥有一个这样的奇怪方法:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e">     * Return the &lt;code&gt;ServletRequest&lt;/code&gt; for which this object
</span><span style="color:#75715e">     * is the facade.  This method must be implemented by a subclass.
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">public</span> HttpServletRequest <span style="color:#a6e22e">getRequest</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>facade <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            facade <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> RequestFacade<span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> facade<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

</code></pre></div><p>其实这个是一种设计模式，叫做门面模式。</p>
<p>因为servlet 执行service() 方法的时候可以看到他传入的静态类型是ServletRequest 也就是说所有继承了ServeltRequest 的子类对象可以被传入service() 方法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">service</span><span style="color:#f92672">(</span>ServletRequest req<span style="color:#f92672">,</span> ServletResponse res<span style="color:#f92672">)</span>
            <span style="color:#66d9ef">throws</span> ServletException<span style="color:#f92672">,</span> IOException<span style="color:#f92672">;</span>
</code></pre></div><p>那么Reqeust 作为Servlet 的子类自然可以传入这个方法，并且向上转型成为ServletReqeust。</p>
<p>但是会遇到一个安全性的问题，如果一个熟悉Tomcat原理的用户，可以将ServletReqeust 转型成为Reqeust</p>
<p>就可以调用他的公共方法了。</p>
<p>所以我们为Request 添加了一个外观类:</p>
<p><img src="data:image/png;base64,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" alt="img"></p>
<p>RequestFacade 和 Request 共同继承了 ServletRequest 这表示他能代替Request 传入Service 方法,并且他的构造方法就是传入一个 Request</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e">    * Construct a wrapper for the specified request.
</span><span style="color:#75715e">    *
</span><span style="color:#75715e">    * @param request The request to be wrapped
</span><span style="color:#75715e">    */</span>
   <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">RequestFacade</span><span style="color:#f92672">(</span>Request request<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

       <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">request</span> <span style="color:#f92672">=</span> request<span style="color:#f92672">;</span>

   <span style="color:#f92672">}</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e">    * The wrapped request.
</span><span style="color:#75715e">    */</span>
   <span style="color:#66d9ef">protected</span> Request request <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>

</code></pre></div><p>也就是说我们可以将他理解为一个Request 的包装,将其中的request 成员私有，他实现的所有HttpServletRequest的方法都是调用Request的对应方法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"> <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getContentLength</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>request <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalStateException<span style="color:#f92672">(</span>
                            sm<span style="color:#f92672">.</span><span style="color:#a6e22e">getString</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;requestFacade.nullRequest&#34;</span><span style="color:#f92672">)</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">return</span> request<span style="color:#f92672">.</span><span style="color:#a6e22e">getContentLength</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>


    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">getContentType</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>request <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalStateException<span style="color:#f92672">(</span>
                            sm<span style="color:#f92672">.</span><span style="color:#a6e22e">getString</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;requestFacade.nullRequest&#34;</span><span style="color:#f92672">)</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">return</span> request<span style="color:#f92672">.</span><span style="color:#a6e22e">getContentType</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

</code></pre></div><p>这时，servlet 程序员仍然可以对Service() 中的ServletRequest 转型成为 RequestFacade 但是只能调用Request 对于HttpServletRequest 的实现。</p>
<p>参考:</p>
<p><a href="https://www.jianshu.com/p/cb27c8da1543">深入理解Tomcat（12）拾遗-MessageBytes</a></p>
<p><a href="https://blog.csdn.net/wangyangzhizhou/article/details/44004501">消息字节——MessageBytes</a></p>
<ul class="pa0">
  
</ul>
<div class="mt6">
      
      
      </div>
    </section>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://xiantang.github.io/" >
    &copy;  xiantang 2020 
  </a>
    <div>












</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
