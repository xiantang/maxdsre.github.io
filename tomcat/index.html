<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>xiantang </title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.63.0-DEV" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.3f5912c237ddd38c8e76debe081c7ca7.css" rel="stylesheet">
    

    

    
      
    

    
    
      <link href="/tomcat/index.xml" rel="alternate" type="application/rss+xml" title="xiantang" />
      <link href="/tomcat/index.xml" rel="feed" type="application/rss+xml" title="xiantang" />
      
    
    
    <meta property="og:title" content="Tomcats" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://xiantang.github.io/tomcat/" />

<meta itemprop="name" content="Tomcats">
<meta itemprop="description" content=""><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Tomcats"/>
<meta name="twitter:description" content=""/>

  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="pb3-m pb6-l bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://xiantang.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      xiantang
    </a>
    <div class="flex-l items-center">
      

      
      













    </div>
  </div>
</nav>

      <div class="tc-l pv3 ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
          Tomcats
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
  <article class="pa3 pa4-ns nested-copy-line-height nested-img">
    <section class="cf ph3 ph5-l pv3 pv4-l f4 tc-l center measure-wide lh-copy mid-gray"></section>
    <section class="flex-ns flex-wrap justify-around mt5">
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Tomcat</span>
    <h1 class="f3 near-black">
      <a href="https://xiantang.github.io/tomcat/io%E6%A8%A1%E5%9E%8B/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      单线程阻塞模型 特点
 单线程:服务端只有一个线程处理客户端的所有请求 阻塞I/O 在读写线程的时候是阻塞的，读取客户端数据要等待客户端发送数据并且把操作系统内核的数据复制到用户进程才能解决阻塞。  缺点
 性能很差，只有一个线程处理数据，当前线程正在处理请求的时候，无法处理其他请求。  多线程阻塞模型 利用多线程机制多分配一个线程，当多个请求过来的时候，服务器端在接受客户端请求后，分别创建多个线程对他们进行处理。客户端与服务器线程的比例是1:1
特点
 能够提高服务器端的并发处理能力，但是每个线程需要分配一个线程池进行操作。 多线程需要上下文切换。  单线程非阻塞 I/O 模型 单线程非阻塞I/O模型的最大特点是，在调用读取和写入接口后立马返回，而不是阻塞。
探讨单线程非阻塞I/O 模型先了解一下非阻塞情况下的套字节检测机制。
 应用程序遍历套字节时间检测,尝试读写。使用一个线程负责遍历套字节列表，同时处理数据的拼凑。 内核遍历套字节检测:  
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Tomcat</span>
    <h1 class="f3 near-black">
      <a href="https://xiantang.github.io/tomcat/tomcat-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-1-httprequestresponse/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      接收器 阀
Tomcat 自带线程池
HTTP Web 服务器也称为超文本传输协议服务器，因为他使用HTTP 与其客户端进行通讯。
HTTP 是应用层协议，由响应和请求组成，是一个标准的B/S 模型,同时也是一个无状态的协议，在同一个客户端中，此次请求和上次请求没有对应关系。
HTTP 允许Web服务器和浏览器通过Internet 发送请求，他是一种基于“请求－响应”的协议。客户端请求一个文件，服务端对于该请求进行响应。
HTTP 请求 一个HTTP 请求包括三部分:
 请求方法－－－统一资源标识符 URI 协议／版本 请求头 实体  POST /ajax/ShowCaptcha HTTP/1.1\r\n Content-Type: application/x-www-form-urlencoded\r\n Host: www.renren.com\r\n Content-Length: 36\r\n \r\n email=%E5%B7%A5&amp;password=asdasdsadas 请求方法 －－ URI －－ 协议／版本
POST /ajax/ShowCaptcha HTTP/1.1\r\n
会出现在第一行
每个请求头之前都会用回车／换行符隔开 (CRLF)
并且请求头和请求实体之间会有一个空行，空行只有 CRLF 符号。CRLF告诉HTTP服务器请求的正文从哪里开始。
HTTP 响应 与HTTP 请求相似，HTTP 响应也分三部分:
 协议－－ 状态码 响应头 响应实体段  HTTP/1.1 200 OK\r\n Date: Sat, 31 Dec 2005 23:59:59 GMT\r\n Content-Type: text/html;charset=ISO-8859-1\r\n Content-Length: 122\r\n \r\n &lt;html&gt; &lt;head&gt; &lt;title&gt;Wrox Homepage&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Tomcat</span>
    <h1 class="f3 near-black">
      <a href="https://xiantang.github.io/tomcat/tomcat-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-2-%E8%BF%9E%E6%8E%A5%E5%99%A8/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      在解释Tomcat 的NIO 连接器之前我们可以来聊一个Tomcat 的StringManage 类
StringManage StringManage 其实是Tomcat用来处理消息的公用类。
其实思路就是每个包名对应一个Stringmanager对象，而非所有公用一个Stringmanager对象！
Tomcat为每一个包提供一个StringManager实例，相当于一个包一个单例的效果
我们来康康这个一个包一个单例是如何实现的呢？
/** * Get the StringManager for a particular package and Locale. If a manager * for a package/Locale combination already exists, it will be reused, else * a new StringManager will be created and returned. * * @param packageName The package name * @param locale The Locale */ public static final synchronized StringManager getManager( String packageName, Locale locale) { Map&lt;Locale,StringManager&gt; map = managers.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Tomcat</span>
    <h1 class="f3 near-black">
      <a href="https://xiantang.github.io/tomcat/tomcat-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-3-%E5%AE%B9%E5%99%A8/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      容器 servlet 容器是用来处理servlet 资源，为Web 客户端填充 response 的模块
Tomcat 有4种容器:
 Engine 整个 Catalina servelt 引擎 Host 包含了一个或者多个Context 容器的虚拟主机 Context 表示一个web app 一个context 有多个Wrapper Wrapper 表示一个独立的servelt  这些容器都实现了Container 接口
我们的本章的上半部分主要讲解的是Wrapper 与 Context
Container 因为所有的容器都实现于Tomcat 的Container 接口所以我们讲解一下Container 接口
Container 主要需要实现的方法是 addChild() 和 removeChild()
/** * Add a new child Container to those associated with this Container, * if supported. Prior to adding this Container to the set of children, * the child&#39;s &lt;code&gt;setParent()&lt;/code&gt; method must be called, with this * Container as an argument.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Tomcat</span>
    <h1 class="f3 near-black">
      <a href="https://xiantang.github.io/tomcat/tomcat-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-4-%E8%BD%BD%E5%85%A5%E5%99%A8/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      类加载器 类加载的好处是可以将Java 类动态的加载到 JVM 中并且运行，就可以在程序运行中再加载类。
在Java 体系中，我们可以将系统分为3中类加载器:
 启动类加载器: 加载Java 的核心库，把核心的Java 类加载进JVM。这个加载器使用的原生 C++ 实现，是所有其他类加载器的父类加载器，负责加载&lt;Java_HOME&gt;/jre/lib 目录下的JVM 指定类库。 拓展类加载器:加载Java 的拓展类库，加载&lt;Java_HOME&gt;/jre/lib/etx 目录中的类。 应用程序类加载器: 系统类加载器负责加载用户类库中的指定类库。  并且类加载器还有各种机制:
  在Java 中，我们用完全匹配类命名来标识一个类，就是用包名.类名，但是在JVM 中一个类由完全匹配类名和一个类加载器实例的ID来标识一个类，当我们判断两个类是否相等的时候，只要他们由两个不同的类加载器加载的前提下才有意义，否则就算相同的字节码，如果由不同的类加载器实例加载，这两个类也是不相同的。这种特征为我们提供了隔离机制。
  类加载器有一个全盘机制当类加载加载一个类的时候，他的依赖的应用的其他所有类都由这个类加载器加载，除非显示的调用这个其他类加载加载。
  对于类加载器加载对象的时候他只会去加载那些必须的对象，只会加载父类对象，理由也很简单为了实现多态，需要将父类的入口方法连接起来，实现方法表。对于这些父类，调用加载子类的类加载器去加载，并且通过向上委托的方式加载。
  只有真正执行到对应的代码，遇到 new 关键词的时候，才会去加载对应的外部引用的类，达到了按需处理的效果。
  如果当前类加载器，已经加载了对应的类，第二次遇到new时候，Java 会隐式的从方法区中获取对应的类。
    载入器 Tomcat 如果使用的系统的类加载器去加载某个servlet 中所有需要使用的类，那么servlet 就可以访问所有的类，比如 Java 虚拟机中环境变量中CLASSPATH 指明路径下的所有类和库。servlet 应该只允许再入WEB-INF/class 中的目录，以及它的子目录下的类。
并且Tomcat 需要实现自定义类加载器的原因是因为为了提供自动重载的功能。类载入器会开启一个线程不断检查文件的时间戳。如果要实现重载入的功能就必须实现Reload 接口。在Tomcat 7 中已经将Reloader 接口合并入Loader 接口中。
​
WebAppLoader 对于Tomcat 的重载，如果你在 conf/server.xml 的 ｀｀标签设置了 reloadable 为ture 的话,Tomcat 会为你开启一个后台线程，去监控该 Context 中所有classes 文件的修改，并且重新加载。
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Tomcat</span>
    <h1 class="f3 near-black">
      <a href="https://xiantang.github.io/tomcat/%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2-%E6%89%8B%E5%86%99java-http-server/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      这坑开了有三个多月了，是今年春招的时候开始写的方轮子。感觉很多基本的功能都已经完成了，下面分享上来给大家讲下写这个方轮子的心路历程。
起因 起初在牛客上看到一篇帖子 《震惊！文科生如何三个月转行成为Java工程师？ 》 这个作者自己写了一个HTTP server ,我突然想到为什么我不去实现一个呢？
因为其实在转到 Java（为了就业） 之前我是学习Python的，曾经用Python 实现过一个类似于 Scrapy 的爬虫框架，但是因为转到Java之后迫于繁杂的 Java 知识体系，也就没有想到写轮子这件事。但是这篇博客真的激起了我写轮子的欲望。
如何做？怎么做？ 但是如何从头写一个服务器呢?就是模仿！
我看到那篇帖子的作者曾经提到他是看了一个Java SE的学习视频跟着慢慢写了一个1000多行的服务器，再自己慢慢迭代代码。
行！就这样，去找这个视频！但是发现 作者留下了一个失效百度云地址。不过这怎么能阻挡我写轮子的欲望，经过一下午的谷歌，终于找到了这个视频 2018百战程序员JAVA全系列终结版第11阶：手写服务器httpserver项目。
是一个培训班的视频，起初我有些抵触，因为我觉得对我来说看培训班的视频的学习效率会不怎么高，没想到这个作者讲的十分的好，带我重新理解了一遍，web.xml 解析，反射解耦这些操作。花了两天的时间跟着视频做了一个十分简易的 BIO HTTP server。
看作者源码 一个简易的BIO server 并不使我满足，于是我开始去 Github 上学习作者的源码 WebServer 。当时还对 NIO 没有一个明确的概念，对于 reactor 模型没有一个深刻的概念，不过没有什么能阻挡我的，查阅了资料并且了解了 unix IO 模型之后的我就开始继续看着作者的源码写轮子。
期间主要实现了:
NIO Reactor 我的实现是用一个 Acceptor 阻塞的获取Socket 连接，然后使用多个Poller 非阻塞轮询 socket 读事件，然后交给线程池处理。
其实对于线程池数目与Poller 的调参也有需要注意的点，我这边因为Poller的操作是计算密集型的操作所以选择了 CPU 核心数目+1 的方案，而后面的线程池我则使用的是200个线程(IO 密集型)，而且需要注意的一点是对于溢出调度队列的线程，系统默认是采用抛出异常的方式，我这边采用的是 调用者执行的方式 使用主线程去串行的执行溢出的任务。这样的好处是会慢，但是也不会出现抛出异常的情况。
协同开发 这段时间，因为最最基础的功能已经开发完毕，所以我把我的轮子分享给牛客上认识的春招战友们一起开发。
我最要感谢的是和我一起开发的时候，一直交流的伙伴鸡哥，那段时间我们两个人满脑子都是轮子，考虑 NIO 考虑session的实现，聊到深夜，也与我反复重构了这个项目。
还有就是 offer 收割机表哥，他帮我指出了一个问题，就是 NIO selector 的注册不是并发的，当时我看 WebServer 的作者的时候也没有仔细思考。
    </div>
  </div>
</div>
</div>
      
    </section>

</article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://xiantang.github.io/" >
    &copy;  xiantang 2020 
  </a>
    <div>












</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
