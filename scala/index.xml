<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Scalas on xiantang</title>
    <link>https://xiantang.github.io/scala/</link>
    <description>Recent content in Scalas on xiantang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://xiantang.github.io/scala/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/scala/akka-%E6%BA%90%E7%A0%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/scala/akka-%E6%BA%90%E7%A0%81/</guid>
      <description>object Main1 extends App { val system = ActorSystem(&amp;#34;HelloSystem&amp;#34;) val jazzListener = system.actorOf(Props[Listener]) val musicListener = system.actorOf(Props[Listener]) system.eventStream.subscribe(jazzListener, classOf[Jazz]) // jazzListener 订阅 Jazz 事件  system.eventStream.subscribe(musicListener, classOf[AllKindsOfMusic]) // musicListener 订阅 AllKindsOfMusic 以及它的子类 事件  // 只有 musicListener 接收到这个事件  system.eventStream.publish(Electronic(&amp;#34;Parov Stelar&amp;#34;)) // jazzListener 和 musicListener 都会收到这个事件  system.eventStream.publish(Jazz(&amp;#34;Sonny Rollins&amp;#34;)) } subscribe 逻辑 同步地将 subcriber 和 to 加入到 subscriptions 中，diff 应该是和之前的一次比较保证不会重复发送?
def subscribe(subscriber: Subscriber, to: Classifier): Boolean = subscriptions.synchronized { val diff = subscriptions.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/scala/learn-scala/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/scala/learn-scala/</guid>
      <description>声明隐式转换
这里的问题是 2*r 等价于 2. 叫 r)，因此这是一个对 2 这个整数的方法调 用。 但Int类并没有一个接收Rational参数的乘法方法一一它没法有这样一 个方法，因为 Rational 类并不是 Scala类库中的标准类
不过， Scala有另外一种方式来解决这个问题 :可以创建一个隐式转换( implicit conversion )，在需要时自动将整数转换成有理数 。 可以往解释器里添加行:
implicit def inToRational(x :Int) = new Rational(x) val r = new Rational(2,3) println(2*r) 生成器
def scalaFiles = for { file &amp;lt;- fileHere if file.getName.endsWith(&amp;#34;.sh&amp;#34;) } yield file scalaFiles 每次迭代生成一个可以被记住的值
函数和闭包 局部函数 既然现在 processLine 定义在 processFile 内部，我们还可以做另一项 改进 。 注意到 filename 和 width 被直接透传给助手函数，完全没有变吗?这 里的传递不是必须的，因为局部函数可以访问包含它们的函数的参数 。 可以直 接使用外部的 processFile 函数的参数.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/scala/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/scala/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>Sbt.
常用命令[ ](https://www.scala-sbt.org/1.x/docs/zh-cn/Running.html#常用命令) 下面是一些非常常用的的 sbt 命令。更加详细的列表请参见 命令行参考。
   clean 删除所有生成的文件 （在 target 目录下）。     compile 编译源文件（在 src/main/scala 和 src/main/java 目录下）。   test 编译和运行所有测试。   console 进入到一个包含所有编译的文件和所有依赖的 classpath 的 Scala 解析器。输入 :quit， Ctrl+D （Unix），或者 Ctrl+Z （Windows） 返回到 sbt。   run &amp;lt;参数&amp;gt;* 在和 sbt 所处的同一个虚拟机上执行项目的 main class。   package 将 src/main/resources 下的文件和 src/main/scala 以及 src/main/java 中编译出来的 class 文件打包成一个 jar 文件。   help &amp;lt;命令&amp;gt; 显示指定的命令的详细帮助信息。如果没有指定命令，会显示所有命令的简介。   reload 重新加载构建定义（build.</description>
    </item>
    
  </channel>
</rss>