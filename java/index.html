<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>xiantang </title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.63.0-DEV" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.3f5912c237ddd38c8e76debe081c7ca7.css" rel="stylesheet">
    

    

    
      
    

    
    
      <link href="/java/index.xml" rel="alternate" type="application/rss+xml" title="xiantang" />
      <link href="/java/index.xml" rel="feed" type="application/rss+xml" title="xiantang" />
      
    
    
    <meta property="og:title" content="Javas" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://xiantang.github.io/java/" />

<meta itemprop="name" content="Javas">
<meta itemprop="description" content=""><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Javas"/>
<meta name="twitter:description" content=""/>

  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="pb3-m pb6-l bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://xiantang.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      xiantang
    </a>
    <div class="flex-l items-center">
      

      
      













    </div>
  </div>
</nav>

      <div class="tc-l pv3 ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
          Javas
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
  <article class="pa3 pa4-ns nested-copy-line-height nested-img">
    <section class="cf ph3 ph5-l pv3 pv4-l f4 tc-l center measure-wide lh-copy mid-gray"></section>
    <section class="flex-ns flex-wrap justify-around mt5">
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Java</span>
    <h1 class="f3 near-black">
      <a href="https://xiantang.github.io/java/classloader/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      实现容器热加载机制 什么是双亲委任模型？ 双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派父类加载器去完成。每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个请求（他的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。
从Java 开发人员的角度来看，类加载还可以再细致一些，绝大部分Java 程序员都会使用以下 3 种系统提供的类加载器:
 启动类加载器（Bootstrap ClassLoader）：这个类加载器复杂将存放在 JAVA_HOME/lib 目录中的，或者被-Xbootclasspath 参数所指定的路径种的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录下也不会重载）。 扩展类加载器（Extension ClassLoader）：这个类加载器由sun.misc.Launcher$ExtClassLoader实现，它负责夹杂JAVA_HOME/lib/ext 目录下的，或者被java.ext.dirs 系统变量所指定的路径种的所有类库。开发者可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher$AppClassLoader 实现。由于这个类加载器是ClassLoader 种的getSystemClassLoader方法的返回值，所以也成为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库。开发者可以直接使用这个类加载器，如果应用中没有定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。  双亲委派模型的好处 双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派父类加载器去完成。每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个请求（他的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。
双亲委派是如何实现的呢？ protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException{ // First, check if the class has already been loaded  Class c = findLoadedClass(name); if (c == null) { try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found  // from the non-null parent class loader  } if (c == null) { // If still not found, then invoke findClass in order  // to find the class.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Java</span>
    <h1 class="f3 near-black">
      <a href="https://xiantang.github.io/java/idea/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      在 Intelij IDEA 中修改 maven 为国内镜像 国内镜像：阿里 打开 IntelliJ IDEA-&gt;Settings -&gt;Build, Execution, Deployment -&gt; Build Tools &gt; Maven 或者直接搜索 maven 具体如下图所示： 而一般情况下在 c:\Users\xx.m2 \ 这个目录下面没有 settings.xml 文件，我们可以新建一个，settings.xml 文件下的内容是：直接粘贴复制保存在上图所示的目录下面就可以了. 需要注意的是，需要点击上图所示右下角的 override。
&lt;settings xmlns=&#34;http://maven.apache.org/SETTINGS/1.0.0&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:schemaLocation=&#34;http://maven.apache.org/SETTINGS/1.0.0 https://maven.apache.org/xsd/settings-1.0.0.xsd&#34;&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;/settings&gt; 如果是 linux 系统，操作过程基本相同，只是 settings.xml 文件的存放路径不一样，不过都可以通过上面截图所示的页面中查到。
idea 常用快捷键 ctrl+N 生成代码
ctrl+shift+A 命令全搜索.
This is almost always followed by Ctrl + Alt + Left to get back to where I was (Ctrl + Alt + Right works to “go forward” again).
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Java</span>
    <h1 class="f3 near-black">
      <a href="https://xiantang.github.io/java/javacollection/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      TODO  集合类的各个使用环境  Java容器 集合体系结构 集合作为一个容器，可以存储多个元素,java提供了多种集合类。将集合类中共性的内容，不断向上抽取，最终形成了集合的体系结构。 Map和Set接口继承Collection List继承ListIterator和Collection Collection和ListIterator继承Iterator
List和队列的区别 Queue接口与List、Set同一级别，都是继承了Collection接口。 LinkedList实现了Queue接口，Queue接口窄化了LinkedList其他方法的访问，就是如果接口参数是Queue的话，只能访问Queue定义的方法。
阻塞队列 试图向一个满的队列或者一个空的阻塞队列存入一个值的时候会阻塞线程。在多线程合作的时候阻塞线程是一个很好的工具。
HashMap 和 HashTable 还有ConcurrentHashMap的区别 以及扩容机制 HashTable 是传统的集合类 已经过时了，在Java4时候被重写了实现了Map接口。
 相同:  都实现了Map接口   不同:  线程的安全性:HashMap不是synchronized的，HashTable是线程安全的。 多个线程可以共享HashTable,没有正确同步的话，多个线程是无法贡献HashMap的。Java5 提出的ConcurrentHashMap是HashTable的替代，共享性更好。 HashMap可以接受null的key和value,HashTable不行。 HashMap的迭代器是fail-fast的迭代器，但是Hashtable的enumerator迭代器不是fail-fast的。当有其他线程更改了HashMap的结构，就会抛出ConcurrentModificationException。由于在同一时刻只有一个线程修改ConcurrentHashMap所以不需要抛出这个异常。 Hashtable 线程安全使用的是synchronized，因为这个是JVM关键字，是重型操作，所以在单线程下还是HashMap效率高。ConcurrentHashMap使用的是CAS技术，也就是乐观锁。当多个线程需要修改同一个变量时候只有其中一个线程能更新，其他线程都失败，失败的线程不会挂起，而是告知这次竞赛失败。先获取key的hashCode,如果是空的就初始化，初始化的时候如果sizeCtl被修改就直接yield当前线程。如果CAS竞赛成功就创建新的table。    重写equals() 传什么参  自反性：对于任意的引用值x，x.equals(x)一定为true。  对称性：对于任意的引用值x 和 y，当x.equals(y)返回true时， y.equals(x)也一定返回true。  传递性：对于任意的引用值x、y和ｚ，如果x.equals(y)返回true， 并且y.equals(z)也返回true，那么x.equals(z)也一定返回true。  一致性：对于任意的引用值x 和 y，如果用于equals比较的对象信息没有被修 改，多次调用x.equals(y)要么一致地返回true，要么一致地返回false。  非空性：对于任意的非空引用值x，x.equals(null)一定返回false。   HashMap源码解析 HashMap 主要用来存放键值对，它基于哈希表的Map接口实现，是常用的Java集合之一。
 JDK1.8 之前由数组和链表组成，链表主要为了解决冲突 JDK1.8 之后在解决hash冲突的时候采取了较大变化，链表长度大于8链表转换为红黑树（log n）。 初始容量16，尽量先预估自己的数据量来设置初始值。  JDK1.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Java</span>
    <h1 class="f3 near-black">
      <a href="https://xiantang.github.io/java/javaconcurrent/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      TODO  多线程的通信，同步方式 volatile和synchronized的区别 乐观锁与悲观锁? 乐观锁它是怎么实现的? 悲观锁呢?  Java并发 乐观锁 CAS compare and swap(比较与交换)，是一种有名的无锁算法。不用锁的情况下实现多线程的变量同步，在没有线程阻塞 的情况下实现变量同步，也叫非阻塞同步。当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。适用于读较多的情况。 三个操作数:
 需要读写的内存值 V 进行比较的值（预期值） A 拟写入的新值 B 当且仅当预期值和内存值相等，将内存V修改为B，否则什么都不做。一般来说是一个自旋的操作，不断的重试。 CAS, CPU指令，在大多数处理器架构，包括IA32、Space中采用的都是CAS指令，CAS的语义是“我认为V的值应该为A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际为多少”，  悲观锁  资源共享只给一个线程，其他线程阻塞，用完在给其他线程。 适用于写较多的情况。  synchronized 使用场景 线程具有五大状态:
 新建状态：新建线程对象，并没有调用start()方法之前。 就绪状态：调用start()方法之后线程就进入就绪状态，但是并不是说只要调用start()方法线程就马上变为当前线程。 运行状态：线程被设置为当前线程，开始执行run()方法。就是线程进入运行状态 阻塞状态：线程被暂停，比如说调用sleep()方法后线程就进入阻塞状态 死亡状态：线程执行结束  锁类型:
 可重入锁（synchronized和ReentrantLock）：在执行对象中所有同步方法不用再次获得锁 可中断锁（synchronized就不是可中断锁，而Lock是可中断锁）：在等待获取锁过程中可中断 公平锁（ReentrantLock和ReentrantReadWriteLock）： 按等待获取锁的线程的等待时间进行获取，等待时间长的具有优先获取锁权利 读写锁（ReadWriteLock和ReentrantReadWriteLock）：对资源读取和写入的时候拆分为2部分处理，读的时候可以多线程一起读，写的时候必须同步地写  Synchronized与Lock的区别  synchronized关键字 Lock是接口 Synchronized获取锁的线程执行完同步代码，释放锁，线程执行发生异常，jvm会让线程释放锁。Lock 在finally中必须释放锁，不然容易造成死锁。 Synchronized无法判断锁状态，Lock可以判断。 synchronized 少量同步，Lock可以提高线程进行读操作的效率（读写分离）     类型 synchronized Lock     存在层次 Java的关键字，在jvm层次 一个类   锁的释放 获取锁执行完成同步代码，执行发生异常，会有一个monitorexit 来退出 必须在finally释放锁   锁的获取 假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待 分情况而定，Lock有多个锁获取的方式，具体下面会说道，大致就是可以尝试获得锁，线程可以不用一直等待   锁状态 无法判断 可以判断   锁类型 可重入 不可中断 非公平 可重入 可判断 可公平（两者皆可）    synchronized 的锁优化 锁的升级策略: 偏向锁-&gt;轻量级锁-&gt;重量级锁 偏向锁、轻量锁的状态转换以及对象MarkWord的关系
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Java</span>
    <h1 class="f3 near-black">
      <a href="https://xiantang.github.io/java/javaio/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Java IO StringBulider 和StringBuffer区别  String ：字符串常量 StringBuffer 字符串变量(线程安全) StringBuilder 字符串变量(非线程安全)  StringBuilder 和 StringBuffer 还有 String 的区别
 String是不可变对象 public final class String,每次改变等于生成了一个新的String对象。 StringBuffer是可变对象，每次改动都会对StringBuffer 对象本身进行改动。在某些情况下String 的改动被JVM解释称StringBuffer的拼接。 StringBuffer是线程安全的，一个类似String的字符串缓存区，不能修改。 因为可以安全的用于多个线程，所以在实例上的操作就想是串行的。  append():加入到字符缓冲区的末尾。 insert():替换指定位置   StringBuilder是StringBuffer的替换，在字符串缓冲区被单个线程使用的时候，优先使用该类。  NIO 多路复用模型 一个线程去轮询多个socket的状态，只有当socket真正有读写事件的时候，才会真正调用实际的IO操作。
另外多路复用 IO 为何比非阻塞 IO 模型的效率高是因为在非阻塞 IO 中，不断地询问 socket 状态 时通过用户线程去进行的，而在多路复用 IO 中，轮询每个 socket 状态是内核在进行的，这个效 率要比用户线程要高的多。
Selector Selector 类是 NIO 的核心类，Selector 能够检测多个注册的通道上是否有事件发生，如果有事 件发生，便获取事件然后针对每个事件进行相应的响应处理。
流与块的比较 面向块的IO系统以块的形式处理数据。每一个操作都在一步中产生或消费一个数据块。按块要比按流快的多，但面向块的IO缺少了面向流IO所具有的有雅兴和简单性。
Channel 是对于原IO流的模拟，来源和目的对象都必须通过Channel。Buffer实质是一个容器对象，发送给Channel 的所有对象都必须放到Buffer中。
同步、异步、阻塞与非阻塞  同步:就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。 异步:是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。  Linux IO 模型 同步阻塞 IO（blocking IO） 用户空间的应用程序执行一个系统调用，会导致程序阻塞，什么都不干，直到数据准备好。 同步非阻塞 IO（nonblocking IO） 同步非阻塞就是 “每隔一会儿瞄一眼进度条” 的轮询（polling）方式。 缺点:任务完成的响应延迟增大了，每隔一段时间才会轮询义词 read 操作，可能任务在两次轮询之间的任意时间完成。
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Java</span>
    <h1 class="f3 near-black">
      <a href="https://xiantang.github.io/java/jvm/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      反射 Java 反射机制：在程序运行的时候，对于任意的一个类，都能够知道这个类的所有属性和方法，对于任意一个对象可以调用它的任意属性和方法这种动态获取信息以及动态调用对象的方法的功能叫做Java反射(reflect)。
Jvm Java 技术体系  Java 程序设计语言 各种平台上的Java 虚拟机 Java API 类库 来自商业机构和开源社区的第三方Java类库  Java程序设计语言、Java虚拟机、Java API类库这三部分统称为JDK（Java Development Kit）
Java API类库中的Java SE API子集 [1] 和Java虚拟机这两部分统称为JRE（Java Runtime Environment）
 Java ME（Micro Edition）：支持Java程序运行在移动终端（手机、PDA）上的平台，对 Java API有所精简，并加入了针对移动终端的支持，这个版本以前称为J2ME。 Java SE（Standard Edition）：支持面向桌面级应用（如Windows下的应用程序）的Java 平台，提供了完整的Java核心API，这个版本以前称为J2SE。 Java EE（Enterprise Edition）：支持使用多层架构的企业应用（如ERP、CRM应用）的 Java平台，除了提供Java SE API外，还对其做了大量的扩充 [3] 并提供了相关的部署支持，这 个版本以前称为J2EE。  混合语言：
多语言混合编程正成为主流，每种语言都可以针 对自己擅长的方面更好地解决问题。试想一下，在一个项目之中，并行处理用Clojure语言编 写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完 成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像 使用自己语言的原生API一样方便 [1] ，因为它们最终都运行在一个虚拟机之上。
64 位虚拟机：
Java程序运行在64位虚拟机上需要付出比较大的额外代价：首先是内 存问题，由于指针膨胀和各种数据类型对齐补白的原因，运行于64位系统上的Java应用需要 消耗更多的内存，通常要比32位系统额外增加10%～30%的内存消耗；
普通对象指针压缩:
（-XX：+UseCompressedOops，这个参数不建议显式设 置，建议维持默认由虚拟机的Ergonomics机制自动开启）
Java 内存区域 与 内存溢出异常 程序计数器 程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线 程所执行的字节码的行号指示器。
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Java</span>
    <h1 class="f3 near-black">
      <a href="https://xiantang.github.io/java/quartz%E9%87%8D%E5%A4%8D%E8%B0%83%E5%BA%A6%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      序列化问题 行锁保证线程安全 类加载 为什么事务就能保证安全了？  触发JOB fire
TRIGGER_STATE 是当前trigger 的状态 PREV_FIRE_TIME 是上次触发的时间
locks表 Quart 支持分布式，也就是会存在多个线程同时抢占资源的情况处理这种状况。
protected &lt;T&gt; T executeInNonManagedTXLock( String lockName, TransactionCallback&lt;T&gt; txCallback, final TransactionValidator&lt;T&gt; txValidator) throws JobPersistenceException { boolean transOwner = false; Connection conn = null; try { if (lockName != null) { // If we aren&#39;t using db locks, then delay getting DB connection  // until after acquiring the lock since it isn&#39;t needed.  if (getLockHandler().
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Java</span>
    <h1 class="f3 near-black">
      <a href="https://xiantang.github.io/java/%E7%AC%94%E7%BB%8F/360-%E7%AC%94%E8%AF%95/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Java</span>
    <h1 class="f3 near-black">
      <a href="https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/kyligence%E5%AE%9E%E4%B9%A0/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      一面
问的十分基础
java 的所有基本类型
String 是可变类型吗 String的实现有什么不同
volatile 的几个作用
final 的作用
有什么问题？
作为程序员在Kyligence 的一天是怎么样的？
然后聊天
二面
讲一下你对泛型的理解
能不能声明一个 Lista = new ArrayList并且 B 继承 A
三次握手 为什么要有三次握手
基于 TCP 设计一个文件上传的协议（emmm 爱奇艺三面问到)
垃圾回收机制 讲一个你比较熟悉的垃圾回收器
手撕代码（纸上）
三个线程ABC 反复交替打印 A B C 撕了
实现一个计算器 没有括号 两个栈就完事了 撕了
有什么问题？
贵公司如何做code review的？
三面
leader 好像不知道我来面的什么岗
我随口说了个实习生
我人都傻了
然后让我等offer邮件
HR
主要问了一下意向 看到钱那么少我也没什么兴趣，直言钱太少，意向不大
估计不会发offer了
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Java</span>
    <h1 class="f3 near-black">
      <a href="https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E5%A4%B4%E6%9D%A1%E4%B8%80%E9%9D%A2/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      static 的sync 和 实例的sync 垃圾回收器 内存碎片 二叉树的转链表 JVM 排查命令 JVM OOM 有哪几种情况 juc 下面的栅栏 这些类有了解过吗？ Java 内存模型 线程池参数 主要作用 我爱小a redis 数据结构 有限状态机 CAS 是什么 ABA 问题 分布式锁的实现 JVM 内存模型 数据库索引的实现 叶子节点内部节点的区别 rabbitMQ 怎么用吗 java 的垃圾回收机制 HashMap 为什么线程不安全 场景 hashcode 怎么用 equal重写  对于一个指定位置的水坑，他所能承载的水的垂直数目取决于左右两边最高中的较小的那一块，所以通过遍历，就可以得出。
class Solution { public int trap(int[] height) { int sum = 0; int left = 0; int right = height.length-1; int left_max =0; int right_max = 0; while(left&lt;right){ if(height[left]&lt;height[right]){ if(height[left]&gt;left_max){ left_max = height[left]; } else{ sum += left_max-height[left]; } left++; } else{ if(height[right]&gt;right_max){ right_max = height[right]; } else{ sum += right_max-height[right]; } right--; } } return sum; } } 用双指针来做，对于一个数组，我们分别定义left，right 如果height[left]&gt;height[right] 说明right决定了这个位置水的容量 如果大于最大的就跟新小于就sum++
    </div>
  </div>
</div>
</div>
      
    </section>

<ul class="pagination">
    
    <li class="page-item">
        <a href="/java/" class="page-link" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
    </li>
    
    <li class="page-item disabled">
    <a  class="page-link" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
    </li>
    
    
    
    
    
    
    
        
        
    
    
    <li class="page-item active"><a class="page-link" href="/java/">1</a></li>
    
    
    
    
    
    
        
        
    
    
    <li class="page-item"><a class="page-link" href="/java/page/2/">2</a></li>
    
    
    <li class="page-item">
    <a href="/java/page/2/" class="page-link" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
    </li>
    
    <li class="page-item">
        <a href="/java/page/2/" class="page-link" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
    </li>
    
</ul>

</article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://xiantang.github.io/" >
    &copy;  xiantang 2020 
  </a>
    <div>












</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
