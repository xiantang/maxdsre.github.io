<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javas on xiantang</title>
    <link>https://xiantang.github.io/java/</link>
    <description>Recent content in Javas on xiantang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://xiantang.github.io/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/classloader/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/classloader/</guid>
      <description>实现容器热加载机制 什么是双亲委任模型？ 双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派父类加载器去完成。每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个请求（他的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。
从Java 开发人员的角度来看，类加载还可以再细致一些，绝大部分Java 程序员都会使用以下 3 种系统提供的类加载器:
 启动类加载器（Bootstrap ClassLoader）：这个类加载器复杂将存放在 JAVA_HOME/lib 目录中的，或者被-Xbootclasspath 参数所指定的路径种的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录下也不会重载）。 扩展类加载器（Extension ClassLoader）：这个类加载器由sun.misc.Launcher$ExtClassLoader实现，它负责夹杂JAVA_HOME/lib/ext 目录下的，或者被java.ext.dirs 系统变量所指定的路径种的所有类库。开发者可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher$AppClassLoader 实现。由于这个类加载器是ClassLoader 种的getSystemClassLoader方法的返回值，所以也成为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库。开发者可以直接使用这个类加载器，如果应用中没有定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。  双亲委派模型的好处 双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派父类加载器去完成。每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个请求（他的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。
双亲委派是如何实现的呢？ protected synchronized Class&amp;lt;?&amp;gt; loadClass(String name, boolean resolve) throws ClassNotFoundException{ // First, check if the class has already been loaded  Class c = findLoadedClass(name); if (c == null) { try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found  // from the non-null parent class loader  } if (c == null) { // If still not found, then invoke findClass in order  // to find the class.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/idea/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/idea/</guid>
      <description>在 Intelij IDEA 中修改 maven 为国内镜像 国内镜像：阿里 打开 IntelliJ IDEA-&amp;gt;Settings -&amp;gt;Build, Execution, Deployment -&amp;gt; Build Tools &amp;gt; Maven 或者直接搜索 maven 具体如下图所示： 而一般情况下在 c:\Users\xx.m2 \ 这个目录下面没有 settings.xml 文件，我们可以新建一个，settings.xml 文件下的内容是：直接粘贴复制保存在上图所示的目录下面就可以了. 需要注意的是，需要点击上图所示右下角的 override。
&amp;lt;settings xmlns=&amp;#34;http://maven.apache.org/SETTINGS/1.0.0&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:schemaLocation=&amp;#34;http://maven.apache.org/SETTINGS/1.0.0 https://maven.apache.org/xsd/settings-1.0.0.xsd&amp;#34;&amp;gt; &amp;lt;mirrors&amp;gt; &amp;lt;mirror&amp;gt; &amp;lt;id&amp;gt;alimaven&amp;lt;/id&amp;gt; &amp;lt;name&amp;gt;aliyun maven&amp;lt;/name&amp;gt; &amp;lt;url&amp;gt;http://maven.aliyun.com/nexus/content/groups/public/&amp;lt;/url&amp;gt; &amp;lt;mirrorOf&amp;gt;central&amp;lt;/mirrorOf&amp;gt; &amp;lt;/mirror&amp;gt; &amp;lt;/mirrors&amp;gt; &amp;lt;/settings&amp;gt; 如果是 linux 系统，操作过程基本相同，只是 settings.xml 文件的存放路径不一样，不过都可以通过上面截图所示的页面中查到。
idea 常用快捷键 ctrl+N 生成代码
ctrl+shift+A 命令全搜索.
This is almost always followed by Ctrl + Alt + Left to get back to where I was (Ctrl + Alt + Right works to “go forward” again).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/javacollection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/javacollection/</guid>
      <description>TODO  集合类的各个使用环境  Java容器 集合体系结构 集合作为一个容器，可以存储多个元素,java提供了多种集合类。将集合类中共性的内容，不断向上抽取，最终形成了集合的体系结构。 Map和Set接口继承Collection List继承ListIterator和Collection Collection和ListIterator继承Iterator
List和队列的区别 Queue接口与List、Set同一级别，都是继承了Collection接口。 LinkedList实现了Queue接口，Queue接口窄化了LinkedList其他方法的访问，就是如果接口参数是Queue的话，只能访问Queue定义的方法。
阻塞队列 试图向一个满的队列或者一个空的阻塞队列存入一个值的时候会阻塞线程。在多线程合作的时候阻塞线程是一个很好的工具。
HashMap 和 HashTable 还有ConcurrentHashMap的区别 以及扩容机制 HashTable 是传统的集合类 已经过时了，在Java4时候被重写了实现了Map接口。
 相同:  都实现了Map接口   不同:  线程的安全性:HashMap不是synchronized的，HashTable是线程安全的。 多个线程可以共享HashTable,没有正确同步的话，多个线程是无法贡献HashMap的。Java5 提出的ConcurrentHashMap是HashTable的替代，共享性更好。 HashMap可以接受null的key和value,HashTable不行。 HashMap的迭代器是fail-fast的迭代器，但是Hashtable的enumerator迭代器不是fail-fast的。当有其他线程更改了HashMap的结构，就会抛出ConcurrentModificationException。由于在同一时刻只有一个线程修改ConcurrentHashMap所以不需要抛出这个异常。 Hashtable 线程安全使用的是synchronized，因为这个是JVM关键字，是重型操作，所以在单线程下还是HashMap效率高。ConcurrentHashMap使用的是CAS技术，也就是乐观锁。当多个线程需要修改同一个变量时候只有其中一个线程能更新，其他线程都失败，失败的线程不会挂起，而是告知这次竞赛失败。先获取key的hashCode,如果是空的就初始化，初始化的时候如果sizeCtl被修改就直接yield当前线程。如果CAS竞赛成功就创建新的table。    重写equals() 传什么参  自反性：对于任意的引用值x，x.equals(x)一定为true。  对称性：对于任意的引用值x 和 y，当x.equals(y)返回true时， y.equals(x)也一定返回true。  传递性：对于任意的引用值x、y和ｚ，如果x.equals(y)返回true， 并且y.equals(z)也返回true，那么x.equals(z)也一定返回true。  一致性：对于任意的引用值x 和 y，如果用于equals比较的对象信息没有被修 改，多次调用x.equals(y)要么一致地返回true，要么一致地返回false。  非空性：对于任意的非空引用值x，x.equals(null)一定返回false。   HashMap源码解析 HashMap 主要用来存放键值对，它基于哈希表的Map接口实现，是常用的Java集合之一。
 JDK1.8 之前由数组和链表组成，链表主要为了解决冲突 JDK1.8 之后在解决hash冲突的时候采取了较大变化，链表长度大于8链表转换为红黑树（log n）。 初始容量16，尽量先预估自己的数据量来设置初始值。  JDK1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/javaconcurrent/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/javaconcurrent/</guid>
      <description>TODO  多线程的通信，同步方式 volatile和synchronized的区别 乐观锁与悲观锁? 乐观锁它是怎么实现的? 悲观锁呢?  Java并发 乐观锁 CAS compare and swap(比较与交换)，是一种有名的无锁算法。不用锁的情况下实现多线程的变量同步，在没有线程阻塞 的情况下实现变量同步，也叫非阻塞同步。当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。适用于读较多的情况。 三个操作数:
 需要读写的内存值 V 进行比较的值（预期值） A 拟写入的新值 B 当且仅当预期值和内存值相等，将内存V修改为B，否则什么都不做。一般来说是一个自旋的操作，不断的重试。 CAS, CPU指令，在大多数处理器架构，包括IA32、Space中采用的都是CAS指令，CAS的语义是“我认为V的值应该为A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际为多少”，  悲观锁  资源共享只给一个线程，其他线程阻塞，用完在给其他线程。 适用于写较多的情况。  synchronized 使用场景 线程具有五大状态:
 新建状态：新建线程对象，并没有调用start()方法之前。 就绪状态：调用start()方法之后线程就进入就绪状态，但是并不是说只要调用start()方法线程就马上变为当前线程。 运行状态：线程被设置为当前线程，开始执行run()方法。就是线程进入运行状态 阻塞状态：线程被暂停，比如说调用sleep()方法后线程就进入阻塞状态 死亡状态：线程执行结束  锁类型:
 可重入锁（synchronized和ReentrantLock）：在执行对象中所有同步方法不用再次获得锁 可中断锁（synchronized就不是可中断锁，而Lock是可中断锁）：在等待获取锁过程中可中断 公平锁（ReentrantLock和ReentrantReadWriteLock）： 按等待获取锁的线程的等待时间进行获取，等待时间长的具有优先获取锁权利 读写锁（ReadWriteLock和ReentrantReadWriteLock）：对资源读取和写入的时候拆分为2部分处理，读的时候可以多线程一起读，写的时候必须同步地写  Synchronized与Lock的区别  synchronized关键字 Lock是接口 Synchronized获取锁的线程执行完同步代码，释放锁，线程执行发生异常，jvm会让线程释放锁。Lock 在finally中必须释放锁，不然容易造成死锁。 Synchronized无法判断锁状态，Lock可以判断。 synchronized 少量同步，Lock可以提高线程进行读操作的效率（读写分离）     类型 synchronized Lock     存在层次 Java的关键字，在jvm层次 一个类   锁的释放 获取锁执行完成同步代码，执行发生异常，会有一个monitorexit 来退出 必须在finally释放锁   锁的获取 假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待 分情况而定，Lock有多个锁获取的方式，具体下面会说道，大致就是可以尝试获得锁，线程可以不用一直等待   锁状态 无法判断 可以判断   锁类型 可重入 不可中断 非公平 可重入 可判断 可公平（两者皆可）    synchronized 的锁优化 锁的升级策略: 偏向锁-&amp;gt;轻量级锁-&amp;gt;重量级锁 偏向锁、轻量锁的状态转换以及对象MarkWord的关系</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/javaio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/javaio/</guid>
      <description>Java IO StringBulider 和StringBuffer区别  String ：字符串常量 StringBuffer 字符串变量(线程安全) StringBuilder 字符串变量(非线程安全)  StringBuilder 和 StringBuffer 还有 String 的区别
 String是不可变对象 public final class String,每次改变等于生成了一个新的String对象。 StringBuffer是可变对象，每次改动都会对StringBuffer 对象本身进行改动。在某些情况下String 的改动被JVM解释称StringBuffer的拼接。 StringBuffer是线程安全的，一个类似String的字符串缓存区，不能修改。 因为可以安全的用于多个线程，所以在实例上的操作就想是串行的。  append():加入到字符缓冲区的末尾。 insert():替换指定位置   StringBuilder是StringBuffer的替换，在字符串缓冲区被单个线程使用的时候，优先使用该类。  NIO 多路复用模型 一个线程去轮询多个socket的状态，只有当socket真正有读写事件的时候，才会真正调用实际的IO操作。
另外多路复用 IO 为何比非阻塞 IO 模型的效率高是因为在非阻塞 IO 中，不断地询问 socket 状态 时通过用户线程去进行的，而在多路复用 IO 中，轮询每个 socket 状态是内核在进行的，这个效 率要比用户线程要高的多。
Selector Selector 类是 NIO 的核心类，Selector 能够检测多个注册的通道上是否有事件发生，如果有事 件发生，便获取事件然后针对每个事件进行相应的响应处理。
流与块的比较 面向块的IO系统以块的形式处理数据。每一个操作都在一步中产生或消费一个数据块。按块要比按流快的多，但面向块的IO缺少了面向流IO所具有的有雅兴和简单性。
Channel 是对于原IO流的模拟，来源和目的对象都必须通过Channel。Buffer实质是一个容器对象，发送给Channel 的所有对象都必须放到Buffer中。
同步、异步、阻塞与非阻塞  同步:就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。 异步:是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。  Linux IO 模型 同步阻塞 IO（blocking IO） 用户空间的应用程序执行一个系统调用，会导致程序阻塞，什么都不干，直到数据准备好。 同步非阻塞 IO（nonblocking IO） 同步非阻塞就是 “每隔一会儿瞄一眼进度条” 的轮询（polling）方式。 缺点:任务完成的响应延迟增大了，每隔一段时间才会轮询义词 read 操作，可能任务在两次轮询之间的任意时间完成。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/jvm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/jvm/</guid>
      <description>反射 Java 反射机制：在程序运行的时候，对于任意的一个类，都能够知道这个类的所有属性和方法，对于任意一个对象可以调用它的任意属性和方法这种动态获取信息以及动态调用对象的方法的功能叫做Java反射(reflect)。
Jvm Java 技术体系  Java 程序设计语言 各种平台上的Java 虚拟机 Java API 类库 来自商业机构和开源社区的第三方Java类库  Java程序设计语言、Java虚拟机、Java API类库这三部分统称为JDK（Java Development Kit）
Java API类库中的Java SE API子集 [1] 和Java虚拟机这两部分统称为JRE（Java Runtime Environment）
 Java ME（Micro Edition）：支持Java程序运行在移动终端（手机、PDA）上的平台，对 Java API有所精简，并加入了针对移动终端的支持，这个版本以前称为J2ME。 Java SE（Standard Edition）：支持面向桌面级应用（如Windows下的应用程序）的Java 平台，提供了完整的Java核心API，这个版本以前称为J2SE。 Java EE（Enterprise Edition）：支持使用多层架构的企业应用（如ERP、CRM应用）的 Java平台，除了提供Java SE API外，还对其做了大量的扩充 [3] 并提供了相关的部署支持，这 个版本以前称为J2EE。  混合语言：
多语言混合编程正成为主流，每种语言都可以针 对自己擅长的方面更好地解决问题。试想一下，在一个项目之中，并行处理用Clojure语言编 写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完 成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像 使用自己语言的原生API一样方便 [1] ，因为它们最终都运行在一个虚拟机之上。
64 位虚拟机：
Java程序运行在64位虚拟机上需要付出比较大的额外代价：首先是内 存问题，由于指针膨胀和各种数据类型对齐补白的原因，运行于64位系统上的Java应用需要 消耗更多的内存，通常要比32位系统额外增加10%～30%的内存消耗；
普通对象指针压缩:
（-XX：+UseCompressedOops，这个参数不建议显式设 置，建议维持默认由虚拟机的Ergonomics机制自动开启）
Java 内存区域 与 内存溢出异常 程序计数器 程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线 程所执行的字节码的行号指示器。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/quartz%E9%87%8D%E5%A4%8D%E8%B0%83%E5%BA%A6%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/quartz%E9%87%8D%E5%A4%8D%E8%B0%83%E5%BA%A6%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</guid>
      <description>序列化问题 行锁保证线程安全 类加载 为什么事务就能保证安全了？  触发JOB fire
TRIGGER_STATE 是当前trigger 的状态 PREV_FIRE_TIME 是上次触发的时间
locks表 Quart 支持分布式，也就是会存在多个线程同时抢占资源的情况处理这种状况。
protected &amp;lt;T&amp;gt; T executeInNonManagedTXLock( String lockName, TransactionCallback&amp;lt;T&amp;gt; txCallback, final TransactionValidator&amp;lt;T&amp;gt; txValidator) throws JobPersistenceException { boolean transOwner = false; Connection conn = null; try { if (lockName != null) { // If we aren&amp;#39;t using db locks, then delay getting DB connection  // until after acquiring the lock since it isn&amp;#39;t needed.  if (getLockHandler().</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/%E7%AC%94%E7%BB%8F/360-%E7%AC%94%E8%AF%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/%E7%AC%94%E7%BB%8F/360-%E7%AC%94%E8%AF%95/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/kyligence%E5%AE%9E%E4%B9%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/kyligence%E5%AE%9E%E4%B9%A0/</guid>
      <description>一面
问的十分基础
java 的所有基本类型
String 是可变类型吗 String的实现有什么不同
volatile 的几个作用
final 的作用
有什么问题？
作为程序员在Kyligence 的一天是怎么样的？
然后聊天
二面
讲一下你对泛型的理解
能不能声明一个 Lista = new ArrayList并且 B 继承 A
三次握手 为什么要有三次握手
基于 TCP 设计一个文件上传的协议（emmm 爱奇艺三面问到)
垃圾回收机制 讲一个你比较熟悉的垃圾回收器
手撕代码（纸上）
三个线程ABC 反复交替打印 A B C 撕了
实现一个计算器 没有括号 两个栈就完事了 撕了
有什么问题？
贵公司如何做code review的？
三面
leader 好像不知道我来面的什么岗
我随口说了个实习生
我人都傻了
然后让我等offer邮件
HR
主要问了一下意向 看到钱那么少我也没什么兴趣，直言钱太少，意向不大
估计不会发offer了</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E5%A4%B4%E6%9D%A1%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E5%A4%B4%E6%9D%A1%E4%B8%80%E9%9D%A2/</guid>
      <description>static 的sync 和 实例的sync 垃圾回收器 内存碎片 二叉树的转链表 JVM 排查命令 JVM OOM 有哪几种情况 juc 下面的栅栏 这些类有了解过吗？ Java 内存模型 线程池参数 主要作用 我爱小a redis 数据结构 有限状态机 CAS 是什么 ABA 问题 分布式锁的实现 JVM 内存模型 数据库索引的实现 叶子节点内部节点的区别 rabbitMQ 怎么用吗 java 的垃圾回收机制 HashMap 为什么线程不安全 场景 hashcode 怎么用 equal重写  对于一个指定位置的水坑，他所能承载的水的垂直数目取决于左右两边最高中的较小的那一块，所以通过遍历，就可以得出。
class Solution { public int trap(int[] height) { int sum = 0; int left = 0; int right = height.length-1; int left_max =0; int right_max = 0; while(left&amp;lt;right){ if(height[left]&amp;lt;height[right]){ if(height[left]&amp;gt;left_max){ left_max = height[left]; } else{ sum += left_max-height[left]; } left++; } else{ if(height[right]&amp;gt;right_max){ right_max = height[right]; } else{ sum += right_max-height[right]; } right--; } } return sum; } } 用双指针来做，对于一个数组，我们分别定义left，right 如果height[left]&amp;gt;height[right] 说明right决定了这个位置水的容量 如果大于最大的就跟新小于就sum++</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E5%A4%B4%E6%9D%A1%E4%BA%8C%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E5%A4%B4%E6%9D%A1%E4%BA%8C%E9%9D%A2/</guid>
      <description>在爱奇艺做了什么？ 排障
负载均衡算法 怎么 把流量打均匀 session（redis）
一个对象的生命周期
JVM 是怎么创建一个线程的
 两台机子最多能建立多少个TCP链接  主机{ip，port} - 客户端{ip，port}
ipv4的长度是32位，得2^32，端口16位，得2^16，共计2^48。同时还要受限与最大文件描述符数目及内存限制
  为什么要有三次握手和四次挥手
  三次握手怎么匹配 sq number
  布隆过滤器怎么调参
布隆过滤器的哈希函数是自己实现的吗? 不是
为什么wait time 是2MSL 如果是10MSL 20MSL 会怎么样
MSL 是怎么算出来的？
NIO 的核心理念是什么？为什么叫NIO
NIO 多路复用select() epoll() 演进流程 同步到异步
原子类线程调度的关系
JVM 内存模型（你给我说清楚 是JVM 还是JMM)
  一定要有老年代和新生代吗 没有没关系吗？
这个主要看JVM 规范
  JMM 工作内存 和 主内存主要是什么
栈数据区 操作数
  JMM 最重要的准则是什么 happens before ？</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E6%94%AF%E4%BB%98%E5%AE%9D%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E6%94%AF%E4%BB%98%E5%AE%9D%E4%B8%80%E9%9D%A2/</guid>
      <description>对象存在的周期
java的垃圾回收器 几个
爬虫项目怎么监控价格
redis单点还是集群化 单点可靠性
fork 是 new 一个子进程
redis 在超出内存的情况下怎样进行IO操作
如何学习的 是学习java 还是python
 Java 实现切面变成 和 依赖注入 为什么c/C++不能这样做（扯到了编程范式 java的包访问机制） 通过反射实例化对象，存入到Spring的bean容器中  实例方法和静态方法不一样（感觉打得不够深入）
静态方法怎么用（我把单例模式全答了voliate 饿汉懒汉 枚举）
常见的异常类 （runtimeEx null classnot 索引溢出）
classnotfound 情况 哪几种 （类加载器，环境变量没配（扯淡呢 环境变量没配根本找不到java））
 spring 事物传播机制 （woc 这是什么） 外围方法未开启事务的情况下Propagation.REQUIRED修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。 Propagation.REQUIRED修饰的内部方法会加入到外围方法的事务中，所有Propagation.REQUIRED修饰的内部方法和外围方法均属于同一事务，只要一个方法回滚，整个事务均回滚。 Propagation.REQUIRES_NEW修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。 Propagation.REQUIRES_NEW修饰的内部方法依然会单独开启独立事务，且与外部方法事务也独立，内部方法之间、内部方法和外部方法事务均相互独立，互不干扰。  ThreadLocal 有啥作用（感觉答得不够深）
session和cookie区别 session 怎么多服务器统一（答了redis）
 前端安全 XSS？？  XSS 攻击 通过html 注入 插入恶意脚本，前端没有经过检验就操作 使用正则通过标签替换进行解码 CSRF 攻击 登录网站种下cookie 不小心访问了恶意网站， 你的cookie被恶意网站捕获 请求地址中添加token。    etc/hosts 有啥用</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E6%94%AF%E4%BB%98%E5%AE%9D%E9%A3%8E%E6%8E%A7%E9%83%A8%E9%97%A8%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E6%94%AF%E4%BB%98%E5%AE%9D%E9%A3%8E%E6%8E%A7%E9%83%A8%E9%97%A8%E4%B8%80%E9%9D%A2/</guid>
      <description>遇到的反爬虫
 robot.txt user-agent cookie加密 ip 封禁    验证码怎么破解
  知道CNN技术吗
 答了 卷积神经网络    布隆过滤器误判率 在redis的书上有
  为什么会上布隆过滤器
  mysql 查询优化是怎么优化的
 用between and 如果用 * 就可以走主键索引 但是使用limit 去 * 不符合最左前缀 就会导致不走索引 全量查询    用了ORM吗 用什么连接驱动
 用了mysqldb 没有pymysql    DB里面的事务 讲了事务隔离机制
  将一下未提交读
  讲一下串行读 面试官讲了秒杀场景 可以适用
  爬虫的DFS 有遇到循环的问题吗
  为什么没有用BFS 用的DFS</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E6%9C%89%E8%B5%9E%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E6%9C%89%E8%B5%9E%E4%B8%80%E9%9D%A2/</guid>
      <description>负载均衡算法维持会话使用的算法 7层 nio 中 在 unix 函数用了什么？ epoll ？ cas 自旋的好处？ 线程池如何运作？他的参数是什么？阻塞队列的作用是什么？为什么要有阻塞队列 nio 多路复用是同步还是异步的? mysql 悲观锁乐观锁 用sql 怎么写 线程池在请求来了的时候是怎么创建线程和利用请求队列的？ mysql 事务是怎么实现的? HashMap 线程不安全的情况? 1.8 1.7 分析 聚集索引与非聚集索引的区别 mysql 默认的隔离级别 volatile 的实现 内存屏障的实现 指令重排序的应用场景 mysql 的两个引擎的区别 性能 差多少 为什么？ chm 怎么计算分段的数量 构造函数里面有 忘了 项目中有没有用到过行锁，怎么实现的（四种锁）？ 死锁发生的条件，对锁超时，如果遇到抢占锁怎么办？  LVS 持久性连接 从用户端来解释，就是当一个用户第一次访问被负载均衡代理到后端服务器A并登录后，服务器A上保留了用户的登录信息；当用户再次发送请求时，根据负载均衡策略可能被代理到后端不同的服务器，例如服务器B，由于这台服务器B没有用户的登录信息，所以导致用户需要重新登录。这对用户来说是不可忍受的。所以，在实施负载均衡的时候，我们必须考虑Session的问题。
问题出在哪里？ 如何处理？  会话保持（案例：Nginx、Haproxy） 会话复制（案例：Tomcat） 会话共享（案例：Memcached、Redis）  我们这里主要讲的是 会话保持的方式，这个方式也主要是从负载均衡这一层进行解决。
首先讲两个十分通用的方式吧！
会话保持 IP_HASH 每个请求按照访问的ip的Hash结果进行分配，这样每个访客可以访问同一个后端服务器，达到保持Session的方法。
upstream bakend { ip_hash; server192.168.0.11:80; server192.168.0.12:80; } Cookie 识别 也就是Haproxy在用户第一次访问的后在用户浏览器插入了一个Cookie，用户下一次访问的时候浏览器就会带上这个Cookie给Haproxy，Haproxy进行识别</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E8%85%BE%E8%AE%AF%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E8%85%BE%E8%AE%AF%E4%B8%80%E9%9D%A2/</guid>
      <description>  抽象类和接口有什么区别
  在接口里面怎么去实现一个数据的共享
  有用过注解嘛 （我这里简单的回答了一下，应该要扯到编译时和运行时 和元编程
  spring boot 如何自动配置
  Java 如何去创建一个JDBC连接
  判断变量，两个变量相等 == 和 equal的区别
  HashMap 的工作原理 应该讲一下扩容机制的
  打开腾讯的首页，从你输入网址到时候呈现出来，整个过程会经过哪些环节。
  HTTPS 非对称加密
  长连接和短连接的区别
  什么时候用长连接 什么时候用短链接
  tcp怎么进行流量控制
  linux 命令怎么去抓包一个端口
  用文件A 去替换一个目录下不同层次的文件B
  排序的几种方式 以及他们的区别
  希尔排序 快排 是如何排序的 时间复杂度 思路
  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E8%85%BE%E8%AE%AF%E4%BA%8C%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E8%85%BE%E8%AE%AF%E4%BA%8C%E9%9D%A2/</guid>
      <description>JVM 排查命令
JVM OOM 有哪几种情况
juc 下面的栅栏 这些类有了解过吗？
Java 内存模型
线程池参数 主要作用 我爱小a
redis 数据结构
有限状态机
CAS 是什么 ABA 问题
分布式锁的实现
数据库索引的实现 叶子节点内部节点的区别
最左匹配对于ABC 如果A 相同 比较B 如果B相同比较C
rabbitMQ 怎么用吗
java 的垃圾回收机制
HashMap 为什么线程不安全 场景
hashcode 怎么用 equal重写
 自反性：对于任意的引用值x，x.equals(x)一定为true。  对称性：对于任意的引用值x 和 y，当x.equals(y)返回true时， y.equals(x)也一定返回true。  传递性：对于任意的引用值x、y和ｚ，如果x.equals(y)返回true， 并且y.equals(z)也返回true，那么x.equals(z)也一定返回true。  一致性：对于任意的引用值x 和 y，如果用于equals比较的对象信息没有被修 改，多次调用x.equals(y)要么一致地返回true，要么一致地返回false。  非空性：对于任意的非空引用值x，x.equals(null)一定返回false。   OOM 怎么排查
 看堆栈  方法区 运行时常量池溢出
如果是 PermGen space 就代表属于方法区
 直接内存溢出  Jmap 没有明确的信息</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E8%98%91%E8%8F%87%E8%A1%97%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E8%98%91%E8%8F%87%E8%A1%97%E4%B8%80%E9%9D%A2/</guid>
      <description>负载均衡 DR
HashMap
GC
ping 6w 台虚机怎么做
TCP 定时器
拥塞控制
管道种类</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8D%E7%BD%91%E5%95%86%E9%93%B6%E8%A1%8C%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8D%E7%BD%91%E5%95%86%E9%93%B6%E8%A1%8C%E4%B8%80%E9%9D%A2/</guid>
      <description>1500w数据怎么用redis去重 （答了布隆过滤器）
  AB两个索引 是复合索引 where B=&amp;rdquo;?&amp;rdquo; 会走复合索引吗？
 利用索引中的附加列可以减少搜索的范围，但使用一个具有两列的索引 不同于使用两个单独的索引。如果您知道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不姓，电话簿将没有用处。 在创建复合索引的时候，应该仔细考虑列的顺序。索引中的所有列执行搜索，或者针对前几条的搜索可以使用复合索引。 最左前缀原则是最左优先，以最左边的为起点任何连续的索引都能匹配上    1500w 怎么确定between and 范围
  怎么优化1500w数据中一个区间的数据的查询（我答了limit 1）
  有限状态机的概念
  有限状态机在某个状态出现问题 怎么处理 怎么返回原来的状态
  事务中出现了长时间操作该如何处理
  事务的隔离级别（我答了事务传播。。。。。）
 READ UNCOMMITTED（未提交读） 事务的修改即使没有提交对其他事务都是可见的，事务可以读取未提交的数据也就被称为脏读（Dirty Read） 一般很少使用。 READ COMMITED（提交读） 一个事务开始的时候只能“看见”已经提交事务所做的修改，也就是说一个事务从开始到提交之前，所做的任何修改 都是对其他事务不可见的。 REPEATABLE READ（可重复读） MySQL 的默认事务隔离级别 无法解决环行（Phantom Row） SERIALIZABLE（可串行化）    开启事务的时候update一个数据 被另一个数据操作了怎么处理
  mysql 的锁 了解过吗？
  线程池了解吗</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8D%E7%BD%91%E5%95%86%E9%93%B6%E8%A1%8C%E4%BA%8C%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xiantang.github.io/java/%E9%9D%A2%E7%BB%8F/%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8D%E7%BD%91%E5%95%86%E9%93%B6%E8%A1%8C%E4%BA%8C%E9%9D%A2/</guid>
      <description>Java的内存回收机制
用户态和内核态
喜欢linux的哪一点
linux的内存管理是怎么做的
Java的面向对象思想
用java写过那些项目？</description>
    </item>
    
  </channel>
</rss>