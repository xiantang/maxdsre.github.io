<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>xiantang </title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.63.0-DEV" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.3f5912c237ddd38c8e76debe081c7ca7.css" rel="stylesheet">
    

    

    
      
    

    
    
      <link href="/middware%E4%B8%AD%E9%97%B4%E4%BB%B6/index.xml" rel="alternate" type="application/rss+xml" title="xiantang" />
      <link href="/middware%E4%B8%AD%E9%97%B4%E4%BB%B6/index.xml" rel="feed" type="application/rss+xml" title="xiantang" />
      
    
    
    <meta property="og:title" content="Middware(中间件)s" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://xiantang.github.io/middware%E4%B8%AD%E9%97%B4%E4%BB%B6/" />

<meta itemprop="name" content="Middware(中间件)s">
<meta itemprop="description" content=""><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Middware(中间件)s"/>
<meta name="twitter:description" content=""/>

  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="pb3-m pb6-l bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://xiantang.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      xiantang
    </a>
    <div class="flex-l items-center">
      

      
      













    </div>
  </div>
</nav>

      <div class="tc-l pv3 ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
          Middware(中间件)s
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
  <article class="pa3 pa4-ns nested-copy-line-height nested-img">
    <section class="cf ph3 ph5-l pv3 pv4-l f4 tc-l center measure-wide lh-copy mid-gray"></section>
    <section class="flex-ns flex-wrap justify-around mt5">
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Middware(中间件)</span>
    <h1 class="f3 near-black">
      <a href="https://xiantang.github.io/middware%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      kafka 基础知识
 Topic：特指Kafka处理的消息源的不同分类，其实也可以理解为对不同消息源的区分的一个标识； Partition：Topic物理上的分组，一个topic可以设置为多个partition，每个partition都是一个有序的队列，partition中的每条消息都会被分配一个有序的id（offset）； Message：消息，是通信的基本单位，每个producer可以向一个topic（主题）发送一些消息； Producers：消息和数据生产者，向Kafka的一个topic发送消息的过程叫做producers（producer可以选择向topic哪一个partition发送数据）。 Consumers：消息和数据消费者，接收topics并处理其发布的消息的过程叫做consumer，同一个topic的数据可以被多个consumer接收； Broker：缓存代理，Kafka集群中的一台或多台服务器统称为broker。  在调用conusmer API时，一般都会指定一个consumer group，该group订阅的topic的每一条消息都发送到这个group的某一台机器上。借用官网一张图来详细介绍一下这种情况，假如kafka集群有两台broker，集群上有一个topic，它有4个partition，partition 0和1在broker1上，partition 2和3在broker2上，这时有两个consumer group同时订阅这个topic，其中一个group有2个consumer，另一个consumer有4个consumer，则它们的订阅消息情况如下图所示：
consumerGroup
因为group A只有两个consumer，所以一个consumer会消费两个partition；而group B有4个consumer，一个consumer会去消费一个partition。这里要注意的是，kafka可以保证一个partition内的数据是有序的，所以group B中的consumer收到的数据是可以保证有序的，但是Group A中的consumer就无法保证了。
group读取topic，partition分配机制是：
 如果group中的consumer数小于topic中的partition数，那么group中的consumer就会消费多个partition； 如果group中的consumer数等于topic中的partition数，那么group中的一个consumer就会消费topic中的一个partition； 如果group中的consumer数大于topic中的partition数，那么group中就会有一部分的consumer处于空闲状态。  
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Middware(中间件)</span>
    <h1 class="f3 near-black">
      <a href="https://xiantang.github.io/middware%E4%B8%AD%E9%97%B4%E4%BB%B6/limiterrater/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      QS 接口调用频率限制
背景
分析了一下之前 890 的事故，结合之前的代码逻辑聊一下吧.
因为我们服务端调用代码的逻辑为异步，所以在请求的过程中是没有阻塞的。
def usersList(projectId: Int, ai: String, groupId: String, field: String, attrList: Seq[String], start: Int, end: Int): Future[Seq[UserInfo]] = { var index = start val requests = new ArrayBuffer[GroupUsersRequest]() // todo: 一个登陆用户对应多个设备的情况下 total 小于实际设备数  while (index &lt; end) { val request = GroupUsersRequest( ....... ) } // 同时向qs请求  Future.traverse(requests.toList) { request =&gt; requestInsight(request) }.map(_.flatten) } 18 w 个用户数据 会被切分成为 180 个 1000为单位的查询请求，由于没有阻塞 所以每台机器会瞬间发送 45 个请求到qs，也就是几毫秒发 180 连接到 QS，最终这些请求会变成查询压力打到数据库，将数据打挂。
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Middware(中间件)</span>
    <h1 class="f3 near-black">
      <a href="https://xiantang.github.io/middware%E4%B8%AD%E9%97%B4%E4%BB%B6/rabbitmq/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      rabbitmq-server用来启动RabbitMQ服务器进程：
 # rabbitmq-server -detached
 
    </div>
  </div>
</div>
</div>
      
    </section>

</article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://xiantang.github.io/" >
    &copy;  xiantang 2020 
  </a>
    <div>












</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
