<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>xiantang </title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.63.0-DEV" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.3f5912c237ddd38c8e76debe081c7ca7.css" rel="stylesheet">
    

    

    
      
    

    
    
    <meta property="og:title" content="" />
<meta property="og:description" content="Java.lang.object 定义了两个非常重要的方法:
 public boolean equals(Object obj) public int hashCode()  equals() 方法 在Java 中 equals()是用来比较两个对象是否相等。主要分为两个方面的比较:
 浅比较(Shallow comparison):在Java.lang.Object 类中默认的实现是简单的比较两个引用(假设是x和y)是否指向同样的对象。由于Object类没有定义其状态的数据成员，所以也称之为浅比较(Shallow comparison)。 深比较(Deep Comparison):假设一个类提供了拥有对equals()方法的自己的实现，目的去比较具有w.r.t状态的对象。意思是对象中的数据成员(例如:域)将会被比较。基于数据成员的比较方式叫做深比较(Deep Comparison)。  语法:
public boolean equals (Object obj) // This method checks if some other Object // passed to it as an argument is equal to // the Object on which it is invoked. //此方法检查是否有其他Object //作为参数传递给它等于 //调用它的Object。 Object类中一些关于equals()的原则:如果某个其他对象等于给定对象，则它遵循以下规则：
 自反性：对于任何引用a,a.equals(a)应该返回true。 对称性：对于任何引用a和b，如果a.equals(b)返回true,那么b.equals(a)必须返回true。 传递性:对于任何引用a，b和c，如果a.equals(b)返回true，　并且b.equals(c)返回true，则a.equals(c)应该返回true。 一致性:对于任何应用a和b,多次调用a.equals(b)始终返回true或始终返回false,前提是在没有修改对象equals比较中使用的信息。  注:对于任何非空的引用a,a.equals(null)应该返回false。
class Geek { public String name; public int id; Geek(String name, int id) { this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xiantang.github.io/translate%E7%BF%BB%E8%AF%91%E4%BD%9C%E5%93%81/equals-%E5%92%8C-hashcode-%E6%96%B9%E6%B3%95%E5%9C%A8java%E4%B8%AD%E7%9A%84%E5%85%B3%E7%B3%BB/" />

<meta itemprop="name" content="">
<meta itemprop="description" content="Java.lang.object 定义了两个非常重要的方法:
 public boolean equals(Object obj) public int hashCode()  equals() 方法 在Java 中 equals()是用来比较两个对象是否相等。主要分为两个方面的比较:
 浅比较(Shallow comparison):在Java.lang.Object 类中默认的实现是简单的比较两个引用(假设是x和y)是否指向同样的对象。由于Object类没有定义其状态的数据成员，所以也称之为浅比较(Shallow comparison)。 深比较(Deep Comparison):假设一个类提供了拥有对equals()方法的自己的实现，目的去比较具有w.r.t状态的对象。意思是对象中的数据成员(例如:域)将会被比较。基于数据成员的比较方式叫做深比较(Deep Comparison)。  语法:
public boolean equals (Object obj) // This method checks if some other Object // passed to it as an argument is equal to // the Object on which it is invoked. //此方法检查是否有其他Object //作为参数传递给它等于 //调用它的Object。 Object类中一些关于equals()的原则:如果某个其他对象等于给定对象，则它遵循以下规则：
 自反性：对于任何引用a,a.equals(a)应该返回true。 对称性：对于任何引用a和b，如果a.equals(b)返回true,那么b.equals(a)必须返回true。 传递性:对于任何引用a，b和c，如果a.equals(b)返回true，　并且b.equals(c)返回true，则a.equals(c)应该返回true。 一致性:对于任何应用a和b,多次调用a.equals(b)始终返回true或始终返回false,前提是在没有修改对象equals比较中使用的信息。  注:对于任何非空的引用a,a.equals(null)应该返回false。
class Geek { public String name; public int id; Geek(String name, int id) { this.">

<meta itemprop="wordCount" content="375">



<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="Java.lang.object 定义了两个非常重要的方法:
 public boolean equals(Object obj) public int hashCode()  equals() 方法 在Java 中 equals()是用来比较两个对象是否相等。主要分为两个方面的比较:
 浅比较(Shallow comparison):在Java.lang.Object 类中默认的实现是简单的比较两个引用(假设是x和y)是否指向同样的对象。由于Object类没有定义其状态的数据成员，所以也称之为浅比较(Shallow comparison)。 深比较(Deep Comparison):假设一个类提供了拥有对equals()方法的自己的实现，目的去比较具有w.r.t状态的对象。意思是对象中的数据成员(例如:域)将会被比较。基于数据成员的比较方式叫做深比较(Deep Comparison)。  语法:
public boolean equals (Object obj) // This method checks if some other Object // passed to it as an argument is equal to // the Object on which it is invoked. //此方法检查是否有其他Object //作为参数传递给它等于 //调用它的Object。 Object类中一些关于equals()的原则:如果某个其他对象等于给定对象，则它遵循以下规则：
 自反性：对于任何引用a,a.equals(a)应该返回true。 对称性：对于任何引用a和b，如果a.equals(b)返回true,那么b.equals(a)必须返回true。 传递性:对于任何引用a，b和c，如果a.equals(b)返回true，　并且b.equals(c)返回true，则a.equals(c)应该返回true。 一致性:对于任何应用a和b,多次调用a.equals(b)始终返回true或始终返回false,前提是在没有修改对象equals比较中使用的信息。  注:对于任何非空的引用a,a.equals(null)应该返回false。
class Geek { public String name; public int id; Geek(String name, int id) { this."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://xiantang.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      xiantang
    </a>
    <div class="flex-l items-center">
      

      
      













    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        TRANSLATE(翻译作品)S
      </p>
      <h1 class="f1 athelas mb1"></h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="0001-01-01T00:00:00Z">January 1, 0001</time>
      
      
    </header>

    <section class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p>Java.lang.object 定义了两个非常重要的方法:</p>
<ul>
<li>public boolean equals(Object obj)</li>
<li>public int hashCode()</li>
</ul>
<h2 id="equals-方法">equals() 方法</h2>
<p>在Java 中 equals()是用来比较两个对象是否相等。主要分为两个方面的比较:</p>
<ul>
<li><strong>浅比较(Shallow comparison)</strong>:在Java.lang.Object 类中默认的实现是简单的比较两个引用(假设是x和y)是否指向同样的对象。由于Object类没有定义其状态的数据成员，所以也称之为浅比较(Shallow comparison)。</li>
<li><strong>深比较(Deep Comparison)</strong>:假设一个类提供了拥有对equals()方法的自己的实现，目的去比较具有w.r.t状态的对象。意思是对象中的数据成员(例如:域)将会被比较。基于数据成员的比较方式叫做深比较(Deep Comparison)。</li>
</ul>
<p>语法:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">equals</span>  <span style="color:#f92672">(</span>Object obj<span style="color:#f92672">)</span>

<span style="color:#75715e">// This method checks if some other Object
</span><span style="color:#75715e"></span><span style="color:#75715e">// passed to it as an argument is equal to 
</span><span style="color:#75715e"></span><span style="color:#75715e">// the Object on which it is invoked.
</span><span style="color:#75715e"></span><span style="color:#75715e">//此方法检查是否有其他Object
</span><span style="color:#75715e"></span><span style="color:#75715e">//作为参数传递给它等于
</span><span style="color:#75715e"></span><span style="color:#75715e">//调用它的Object。
</span></code></pre></div><p><strong>Object类中一些关于equals()的原则</strong>:如果某个其他对象等于给定对象，则它遵循以下规则：</p>
<ul>
<li>自反性：对于任何引用a,<code>a.equals(a)</code>应该返回true。</li>
<li>对称性：对于任何引用a和b，如果<code>a.equals(b)</code>返回true,那么<code>b.equals(a)</code>必须返回true。</li>
<li>传递性:对于任何引用a，b和c，如果<code>a.equals(b)</code>返回true，　并且<code>b.equals(c)</code>返回true，则<code>a.equals(c)</code>应该返回true。</li>
<li>一致性:对于任何应用a和b,多次调用<code>a.equals(b)</code>始终返回true或始终返回false,前提是在没有修改对象<code>equals</code>比较中使用的信息。</li>
</ul>
<p>注:对于任何非空的引用a,<code>a.equals(null)</code>应该返回false。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Geek</span>  
<span style="color:#f92672">{</span> 
      
    <span style="color:#66d9ef">public</span> String name<span style="color:#f92672">;</span> 
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> id<span style="color:#f92672">;</span> 
          
    Geek<span style="color:#f92672">(</span>String name<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> id<span style="color:#f92672">)</span>  
    <span style="color:#f92672">{</span> 
              
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> name<span style="color:#f92672">;</span> 
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">id</span> <span style="color:#f92672">=</span> id<span style="color:#f92672">;</span> 
    <span style="color:#f92672">}</span> 
      
    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>Object obj<span style="color:#f92672">)</span> 
    <span style="color:#f92672">{</span> 
    <span style="color:#75715e">// 是否引用都指向同一个对象  
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// checking if both the object references are  
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// referring to the same object. 
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span> <span style="color:#f92672">=</span><span style="color:#f92672">=</span> obj<span style="color:#f92672">)</span> 
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span> 
        <span style="color:#75715e">// 比较当前对象和传入的参数的类对象是否相同
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// it checks if the argument is of the  
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// type Geek by comparing the classes  
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// of the passed argument and this object. 
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// if(!(obj instanceof Geek)) return false; ---&gt; avoid. 
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>obj <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">|</span><span style="color:#f92672">|</span> obj<span style="color:#f92672">.</span><span style="color:#a6e22e">getClass</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">!</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getClass</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">)</span> 
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span> 
        <span style="color:#75715e">// 向下转型
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// type casting of the argument.  
</span><span style="color:#75715e"></span>        Geek geek <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Geek<span style="color:#f92672">)</span> obj<span style="color:#f92672">;</span> 
        
        <span style="color:#75715e">// 比较成员变量
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// comparing the state of argument with  
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// the state of &#39;this&#39; Object. 
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>geek<span style="color:#f92672">.</span><span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">name</span> <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> geek<span style="color:#f92672">.</span><span style="color:#a6e22e">id</span> <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">id</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span> 
    <span style="color:#f92672">}</span> 
      
    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hashCode</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span> 
    <span style="color:#f92672">{</span> 
        <span style="color:#75715e">// 我们返回Geek_id作为hashcode
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 我们可以计算或者使用对象内存地址的值
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 这取决于你如何实现hashCode（）方法。
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// We are returning the Geek_id  
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// as a hashcode value. 
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// we can also return some  
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// other calculated value or may 
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// be memory address of the  
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// Object on which it is invoked.  
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// it depends on how you implement  
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// hashCode() method. 
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">id</span><span style="color:#f92672">;</span> 
    <span style="color:#f92672">}</span> 
      
<span style="color:#f92672">}</span> 

<span style="color:#75715e">//Driver code 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GFG</span> 
<span style="color:#f92672">{</span> 
      
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span> <span style="color:#f92672">(</span>String<span style="color:#f92672">[</span><span style="color:#f92672">]</span> args<span style="color:#f92672">)</span> 
    <span style="color:#f92672">{</span> 
         
        <span style="color:#75715e">// creating the Objects of Geek class. 
</span><span style="color:#75715e"></span>        Geek g1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Geek<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;aa&#34;</span><span style="color:#f92672">,</span> 1<span style="color:#f92672">)</span><span style="color:#f92672">;</span> 
        Geek g2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Geek<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;aa&#34;</span><span style="color:#f92672">,</span> 1<span style="color:#f92672">)</span><span style="color:#f92672">;</span> 
        <span style="color:#75715e">// 比较上面创建的对象
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// comparing above created Objects. 
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>g1<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span> <span style="color:#f92672">=</span><span style="color:#f92672">=</span> g2<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">)</span> 
        <span style="color:#f92672">{</span> 
  
            <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>g1<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>g2<span style="color:#f92672">)</span><span style="color:#f92672">)</span> 
                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Both Objects are equal. &#34;</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span> 
            <span style="color:#66d9ef">else</span>
                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Both Objects are not equal. &#34;</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span> 
      
        <span style="color:#f92672">}</span> 
        <span style="color:#66d9ef">else</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Both Objects are not equal. &#34;</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>  
    <span style="color:#f92672">}</span>  
<span style="color:#f92672">}</span> 

</code></pre></div><p>输出:</p>
<pre><code>Both Objects are equal.
</code></pre><p>首先我们比较hashCode在两个对象上(g1和g2)如果hashCode产生自两个对象并不意味着这两个对象相同，两个不同的对象的hashCode也是可以相同的。而且，如果他们拥有相同的id(在这种情况下)。那么我们将比较这两个对象w.r.t的状态。如果两个对象具有相同的状态，则他们相等，否则不相等。</p>
<p>在上面的例子中看到这一行：</p>
<pre><code>// if(!(obj instanceof Geek)) return false;--&gt; avoid.--&gt;(a)
</code></pre><p>我们使用下面一行来代替上面这一行:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>obj <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">|</span><span style="color:#f92672">|</span> obj<span style="color:#f92672">.</span><span style="color:#a6e22e">getClass</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">!</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getClass</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span> <span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span><span style="color:#f92672">(</span>y<span style="color:#f92672">)</span>
</code></pre></div><p>原因:引用obj也可以引用Geek对象的子类，在Line(b)中传入的对象是Geek的子类的对象的话，就会返回false，但是在Line(a)中却会返回true。</p>
<h2 id="hashcode-method">hashCode() method</h2>
<p>它将哈希码值作为整数返回。 Hashcode值主要用于基于散列的集合，如<code>HashMap</code>，<code>HashSet</code>，<code>HashTable</code> &hellip; .etc。必须在覆盖<code>equals（）</code>方法的每个类中重写此方法。</p>
<p>语法:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hashCode</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span>

<span style="color:#75715e">// This method returns the hash code value 
</span><span style="color:#75715e"></span><span style="color:#75715e">// for the object on which this method is invoked.
</span><span style="color:#75715e"></span><span style="color:#75715e">// 当这个方法被调用时候返回hashcode
</span></code></pre></div><p><strong>普遍的hashCode规定有</strong>:</p>
<ul>
<li>在代码的运行期时，多次调用hashCode()在同一个对象然后必须返回一致的整数值。如果对象没有在<code>equals(ojb)</code>比较中有成员变量被修改，调用后返回的值都一致。</li>
<li>如果两个对象相等，则根据<code>equals（Object）</code>方法，<code>hashCode（）</code>方法必须在两个对象中的每一个上生成相同的Integer。</li>
<li>如果两个对象不相等，则根据<code>equals（Object）</code>方法，<code>hashCode（）</code>方法在两个对象中的每一个上生成的Integer值不必是不同的。它可以是相同的，但是对于两个不同的对象，通过hashCode产生不同的值对于提高基于散列的集合（如HashMap，HashTable等）的性能会更好。</li>
</ul>
<ul class="pa0">
  
</ul>
<div class="mt6">
      
      
      </div>
    </section>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://xiantang.github.io/" >
    &copy;  xiantang 2020 
  </a>
    <div>












</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
