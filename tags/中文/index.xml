<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>中文 on 自律者自由</title>
    <link>https://vim0.com/tags/%E4%B8%AD%E6%96%87/</link>
    <description>Recent content in 中文 on 自律者自由</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 29 Jun 2022 22:14:09 +0800</lastBuildDate><atom:link href="https://vim0.com/tags/%E4%B8%AD%E6%96%87/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>使用二八法则省力地学习 awk</title>
      <link>https://vim0.com/post/awk/</link>
      <pubDate>Wed, 29 Jun 2022 22:14:09 +0800</pubDate>
      
      <guid>https://vim0.com/post/awk/</guid>
      <description>篇幅只占20%、然而有效性却达到80% -二八法则
 本文你能学到什么？ 在本文中，我们将学习到如何使用二八法则来省力轻松学习 linux 文本处理命令 awk。读完本文你就会学习到一种快速学习的方法， 以及使用 awk 来处理文本和 stdout。
最近在学习 awk 发现真的有很多细节，没办法一开始就抓住最重要的部分，被繁杂的语法所困扰，比较难懂。 于是使用从《软技能-代码之外的生存指南》中学习的二八法则，来实践学习一下 awk 的基本用法，发现效果十分不错。 本文就介绍一下我是如何使用二八法则学习 awk 的。
什么是二八法则？ 在文章的开篇中有提到 &amp;ldquo;篇幅只占20%、然而有效性却达到80%&amp;quot;，叫做 &amp;ldquo;帕累托法则&amp;rdquo;。指出约有 20% 的因素可以影响 80% 的结果。 对于学习技术也是十分的适用，用得最多的 20% 的技术知识点，可以完成 80% 的技术工作。也就是说其实我们只需要专注最常用的 case 来针对性学习，防止真正重要的内容会被埋没在细枝末节中。
如何利用二八法则来学习？ 既然二八法则这么好用那如何来实践呢？ 《软技能-代码之外的生存指南》 主要总结了 10 步，也就是学习一个新的技术可以通过下面十步来完成：
 第一步： 如何开始： 想要用起来 需要哪些基本知识？ 第二步：学科范围：学的东西有多少大？我要怎么做？ 第三步：需要了解基本的用户案例，和常见问题，知道学哪 20% 满足 80% 应用场景 第四步：寻找资源 第五步：定义目标 第六步： 筛选资源 第七步：开始学习 浅尝即止 第八步：动手操作 边学边玩 第九步：全面掌握，学以致用 第十步：好为人师  我们可以将这 10 步分为两大块
 第一块 第一步到第六步，只需要从头到尾执行一次 第二块 第七步到第十步，需要反复执行  其中第一块查找筛选输入资源，定义目标中需要注意的是：</description>
    </item>
    
    <item>
      <title>使用番茄工作法来更好的利用你的时间</title>
      <link>https://vim0.com/post/pomodoro_todo/</link>
      <pubDate>Thu, 03 Feb 2022 00:48:05 +0800</pubDate>
      
      <guid>https://vim0.com/post/pomodoro_todo/</guid>
      <description>对于我还来说，很容易陷入一种工作一整天，一整天都很忙但是不知道在忙什么的状态，导致第二天还是很焦虑，早会还是不知道要讲什么，只能做一下让自己感觉能说的事情。
 为啥要引入番茄工作法：为了解决这个问题，我想了特别多种方法，例如每天写个 TODO list，但是还是会被各种中途插入的事情所浪费很多时间导致自己原来所列的 TODO list 里面的任务都没有办法很好的完成。于是我拿出了我在大学时候一直使用的番茄工作法来应用到我的工作中，同时也看了一些相关的书籍例如《间歇高效率的番茄工作法》。有了一些见解，就用这篇文章来说说下我的番茄工作法。
什么是番茄工作法？ 番茄工作法是由弗朗西斯科·西里在 1992 年创立的时间管理法则。使用一个定时器分割出 25 分钟时间作为工作时间，和 5 分钟的休息时间，这些时间段会被称为 pomodoros 🍅。
目的 使用番茄工作法的目的是辅助你更好的更高效的管理你自己的时间，同时减轻你对于不想做的事情的焦虑，让你更好规划时间，同时尽可能的让你减少被他人打断而造成的上下文切换的次数。
几项原则 番茄工作法虽然表面上是每工作 25 分钟，就可以休息 5 分钟，但是实际上番茄工作法还是有一些原则的，这些原则是我们在使用番茄工作法的时候要遵守的。
  对于任务的拆解，对于一个比较大的任务，我们会对它进行估算，预计用几个番茄钟能完成它。一旦一个任务的预计时间超过 5 - 7 个番茄钟，我们就会对它进行拆解，拆解成小于 5 个番茄钟的子任务。这样的好处是我们不会因为一个任务过于庞大而望而却步，将任务拆细一个个解决它就是了。
  对于一个任务如果在一个番茄钟内完成，并且还剩下一些时间，我们不会立刻去做其他任务，而是会去回顾刚刚完成的任务，把这个事情更加尽善尽美的完成。不用为了那些长远的做不完的任务而焦虑，把当前的做好，就是成功。
  在估算番茄钟的时候，我们会发现有很多细小的任务，类似写个短邮件呀什么的，这个时候我们会把它们凑成一个番茄钟。
  如何实践？ 首先你可以搞一张电子表格或者是纸质的，虽说番茄工作法的作者是会用纸质的方式来搞，但是其实对我来说只要思路对了就行了。
估算任务&amp;amp;拆解任务 估算和拆解任务在一天的开始的时候，我们会在今日工作表中列出今天要做的任务，按照优先级由高到低。并且对于每个任务，我们会对它进行估时，只需要估算出对于每个任务我们需要多少个番茄钟就可以了。同时运用上面的原则，对于较大的任务拆解成小任务，对于对于小于 1 个番茄钟的任务我们把它们凑成一个番茄钟。
正在番茄中 记录你的想法：当你正在番茄钟的里面的时候，你可能心里突然灵感爆发，或者突然想到一件事情，对于这些想法，我们会把它们放在一个列表中，也就是事项盘点列表。当你把这个想法写到这个列表中之后，你就可以立马回到你当前的任务中。倘若这个想法对你来说很重要，那你就可以把它放到今日工作表中，这样你就可以把它放到今日工作表中。在这个番茄钟结束之后下一个番茄钟就开始做这件事。
25 分钟之后回复你：在很多时候，工作中的打扰不可避免，如果你在 office 中，很多人甚至会来你的工位找你，我这边的建议是友好的回复我在忙，你可以稍等一下，我会尽快回复你的。更好的做法是，最大化你当前任务的窗口来挡住不断闪烁的电脑状态栏，每隔一段时间去检查它。同时我在阅读 Marc Andreessen 的《个人效率指南》的时候，看到了一个很好的办法：
 藏在耳机中：工作生活中避免打扰的最好方式就是戴耳机。人们，出于某种原因，觉得打扰一个戴耳机的人会更有负罪感。这很棒，大多时候人们会走到你面前、跟你说话、注意到你戴的耳机、然后用很夸张的嘴型道歉、走开。这个好处是，大多时候人们跟你说话并不是真的有什么事情，而另一些时候，他们完全可以给你发邮件，而你可以稍晚统一处理。所以你不需要听外部的任何事情，甚至耳机的另一头也不需要连任何东西。
 重新估算你的任务：很多时候我们会遇到你乐观地估算了一个任务所消耗的番茄数目，在消耗完这个任务的所有番茄之后，你可以重新的估计剩下完成这个任务的番茄数目，然后对于这些番茄你可以用不同的标记来记录它。 一些最佳实践 摆脱再过 5 分钟就好：在践行番茄工作法的时候，我会带着一个老毛病，就是在番茄完成了之后，我会再想着让我再搞 5 分钟，5 分钟就能完成这个任务，但是很多时候我又多花了半个小时，并且卡在了一个步骤浪费了很多时间。这边的最佳实践是，当你完成了一个番茄钟之后，就不要想着继续再搞几分钟，下一个番茄钟会更好。间歇性的休息能让你更好的梳理思路。</description>
    </item>
    
    <item>
      <title>Unix 如何杀死一个进程和它的子孙进程?</title>
      <link>https://vim0.com/post/kill_process_and_its_childs/</link>
      <pubDate>Mon, 24 Jan 2022 21:49:48 +0800</pubDate>
      
      <guid>https://vim0.com/post/kill_process_and_its_childs/</guid>
      <description>最近周末在维护一个开源项目，叫做 air。它是一个 Golang 的热加载代码的工具，会监听本地的文件变化，然后自动重新加载。
 遇到的问题 最近遇到一个特别有意思的问题，就是使用 kill -9 pid 命令杀死进程的时候虽然会杀死它的子进程，但是它的孙子进程还是会继续存活。
背景 简而言之，就是我们的热加载组件会运行命令，然后会监听文件变化，一旦文件变化就会 kill 掉之前进程，然后重新编译代码，再执行运行的命令。
但是遇到一个用户提了这样一个问题：https://github.com/cosmtrek/air/issues/216#issuecomment-982348931 在执行命令的时候使用 dlv exec --accept-multiclient --log --headless --continue --listen :2345 --api-version 2 ./tmp/main 来运行代码与开启调试，我们的组件不会彻底的将进程杀死，而是会继续存活。导致下次一次起来的时候对应的端口会被占用。
排查问题 通过 ps -efj | grep &amp;quot;tmp/main&amp;quot; 能很清楚的看到实际上运行这条命令会起来三个进程
1594910868 75277 74711 0 10:09PM ttys005 0:00.14 dlv exec --accep xt 75277 0 1 S s005 1594910868 75280 75277 0 10:09PM ttys005 0:00.02 /Library/Develop xt 75280 0 1 S+ s005 1594910868 75281 75280 0 10:09PM ttys005 0:00.</description>
    </item>
    
    <item>
      <title>Golang: 让你的零值更有用</title>
      <link>https://vim0.com/post/make_zero_value_useful/</link>
      <pubDate>Sun, 16 Jan 2022 15:04:40 +0800</pubDate>
      
      <guid>https://vim0.com/post/make_zero_value_useful/</guid>
      <description>Make the zero value useful。 &amp;ndash;Go Proverbs
 让我们从 Golang blog 开始吧：The zero value
 当内存被分配来存储一个值时，无论是通过声明还是调用 make 或 new，并且没有提供明确的初始化，内存被赋予一个默认的初始化。这种值的每个元素都被设置为其类型的零值 (zero value)：布尔值为 false，整数为 0，浮点数为 0.0，字符串为 &amp;quot;&amp;quot;，指针、函数、接口、slice、channel 和 map 为 nil。这种初始化是递归进行的，因此，举例来说，如果没有指定值，结构数组的每个元素都将被归零。
 这样将一个值设置为零值对程序的安全性和正确性做了很大的保证，同样也能很好的保证程序的可读性与简单性。这也就是 Golang 程序员口中的“让零值更有用 (Make the zero value useful)”。
零值 cheat sheet    类型 零值     bool false   int 0   float 0.0   string &amp;quot;&amp;quot;   pointer nil   function nil   slice nil   map nil   channel nil    同时零值的初始化是递归的，因此，如果没有指定值，结构数组的每个元素都将被归零。</description>
    </item>
    
  </channel>
</rss>
