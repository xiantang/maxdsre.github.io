<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Refacotr on 自律者自由</title>
    <link>https://vim0.com/tags/refacotr/</link>
    <description>Recent content in Refacotr on 自律者自由</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 13 Feb 2022 20:23:51 +0800</lastBuildDate><atom:link href="https://vim0.com/tags/refacotr/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Golang: 如何处理日渐膨胀的 interface</title>
      <link>https://vim0.com/post/how_to_fix_big_interface/</link>
      <pubDate>Sun, 13 Feb 2022 20:23:51 +0800</pubDate>
      
      <guid>https://vim0.com/post/how_to_fix_big_interface/</guid>
      <description>The bigger the interface，the weaker the abstraction。Go Proverbs
 先说结论吧，如果你的 Golang interface 有太多函数导致你很难横向拓展，那就把它按照职责拆分成多个 interface，然后使用 embed 组合起来。
遇到的问题 最近在重构一个管理配置的组件，我们会有一个接口并且有超过 5 个以上的 struct 实现这个接口，遇到了一些问题，就是接口膨胀的问题。当你最开始抽象出来一个 interface 的时候，它可能就只有 1 - 2 个函数，很漂亮，并且你的横向拓展的时候也非常的舒服。 但是很多时候现实的情况和你想象的不一样，因为每个实现可能也有自己想暴露出来的不同方法，这个时候你会把这些函数都暴露出来，每个实现为了满足接口都会去实现这个函数，这样就会导致接口膨胀。
举个例子 最开始我有一个接口叫做 ConfigManager，拥有两个函数一个是 HandleResync，一个是 HandleWatch。：
type ConfigManager interface { HandleResync() HandleWatch() } HandleResync 和 HandleWatch 都是对于 etcd 数据的拉取，拉取到数据之后，我们会将数据落盘，并且在内存里面也存储一份最新的副本。
同时这个接口是有两个实现类，一个是 EtcdConfigManager，一个是 FileConfigManager。这里名字比较随意，主要是要表达一个接口的多个实现。
type EtcdConfigManager struct { config *Config } type FileConfigManager struct { config *Config } 但是应为业务不断增长，我们对于 EtcdConfigManager 需要多暴露出来两个接口用来做对内存中副本上报等行为。分别是 GetConfig 和 SetConfig。</description>
    </item>
    
  </channel>
</rss>
